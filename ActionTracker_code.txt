----- FILE: /Users/steve/Library/Mobile Documents/com~apple~CloudDocs/AppProjects/ActionTracker/ActionTracker/CharacterListView.swift -----
//
//  CharacterListView.swift
//  ZombicideCharacters
//
//  Created by Stephen Parker on 4/11/25.
//

import SwiftUI
import SwiftData

struct CharacterListView: View {
    // Use State instead of Query as a workaround for SwiftData issues
    @State private var characters: [Character] = []
    @State private var searchText = ""
    @Binding var isShowingAddCharacter: Bool
    @State private var selectedCharacter: Character?
    @Environment(\.modelContext) private var context
    
    // For debugging
    @State private var debugMessage: String = ""

    var filteredCharacters: [Character] {
        guard !searchText.isEmpty else { return characters }
        
        // Check for special search tokens
        if searchText.lowercased().hasPrefix("set:") {
            let setQuery = searchText.dropFirst(4).trimmingCharacters(in: .whitespaces)
            return characters.filter { 
                guard let set = $0.set else { return false }
                return set.localizedCaseInsensitiveContains(setQuery)
            }
        } else if searchText.lowercased().hasPrefix("skill:") {
            let skillQuery = searchText.dropFirst(6).trimmingCharacters(in: .whitespaces)
            return characters.filter { 
                ($0.skills ?? []).contains { 
                    $0.name.localizedCaseInsensitiveContains(skillQuery)
                }
            }
        } else {
            // Standard search - name or any skill
            return characters.filter {
                $0.name.localizedCaseInsensitiveContains(searchText) ||
                ($0.skills ?? []).contains { $0.name.localizedCaseInsensitiveContains(searchText) } ||
                (($0.set ?? "").localizedCaseInsensitiveContains(searchText))
            }
        }
    }

    var body: some View {
        ZStack {
            NavigationStack {
                VStack(spacing: 0) {
                    // Prominent search bar at the top
                    SearchBar(text: $searchText)
                        .padding(.horizontal)
                        .padding(.vertical, 8)
                        .background(Color(.systemBackground))
                    
                    List {
                        // Debug section (collapsible)
                        DisclosureGroup("Characters / Skills Info") {
                            Text("Characters: \(characters.count)")
                            Button("Refresh Data") {
                                refreshDataModel()
                            }
                            Button("Create Test Character") {
                                createTestCharacter()
                            }
                            Text(debugMessage)
                        }
                        
                        // Navigation link to skill search
                        Section {
                            NavigationLink(destination: SkillSearchView()) {
                                Label("Search by Skills", systemImage: "magnifyingglass")
                            }
                        }

                        // Main list of characters
                        Section("Characters") {
                            ForEach(filteredCharacters) { character in
                                Button {
                                    // Navigate to edit character
                                    selectedCharacter = character
                                } label: {
                                    HStack {
                                        VStack(alignment: .leading) {
                                            HStack {
                                                if character.isFavorite {
                                                    Image(systemName: "star.fill")
                                                        .foregroundColor(.yellow)
                                                }
                                                Text(character.set?.isEmpty == false ? "\(character.name) (\(character.set!))" : character.name)
                                                    .font(.headline)
                                            }
                                            // Display skills sorted by position with enhanced description display
                                            SkillsWithDescriptionView(skills: (character.skills ?? []).sorted { $0.position < $1.position })
                                        }
                                        
                                        Spacer()
                                        
                                        // Favorite toggle button
                                        Button {
                                            toggleFavorite(character)
                                        } label: {
                                            Image(systemName: character.isFavorite ? "star.fill" : "star")
                                                .foregroundColor(character.isFavorite ? .yellow : .gray)
                                        }
                                        .buttonStyle(BorderlessButtonStyle())
                                    }
                                    .foregroundColor(.primary)
                                }
                                .contextMenu {
                                    Button(role: .destructive) {
                                        withAnimation {
                                            // Remove the character from all its skills but don't delete skills
                                            for skill in (character.skills ?? []) {
                                                if skill.characters == nil {
                                                    skill.characters = []
                                                }
                                                skill.characters?.removeAll { $0.id == character.id }
                                            }
                                            // Then delete the character
                                            context.delete(character)
                                        }
                                    } label: {
                                        Label("Delete", systemImage: "trash")
                                    }
                                }
                                .swipeActions(edge: .trailing) {
                                    Button(role: .destructive) {
                                        withAnimation {
                                            // Remove the character from all its skills but don't delete skills
                                            for skill in (character.skills ?? []) {
                                                if skill.characters == nil {
                                                    skill.characters = []
                                                }
                                                skill.characters?.removeAll { $0.id == character.id }
                                            }
                                            // Then delete the character
                                            context.delete(character)
                                        }
                                    } label: {
                                        Label("Delete", systemImage: "trash")
                                    }
                                }
                            }
                        }
                    }
                    .searchSuggestions {
                        if searchText.isEmpty {
                            Text("Try searching by name")
                                .searchCompletion("Fred")
                            Text("Search by set")
                                .searchCompletion("set: Core")
                            Text("Filter by skill")
                                .searchCompletion("skill: +1 Die")
                        }
                    }
                    .modifier(CharacterSeeder())
                    .listStyle(PlainListStyle())
                }
                // No toolbar needed anymore as options moved to HeaderView
                .onAppear {
                    refreshDataModel()
                }
                .onChange(of: isShowingAddCharacter) { oldValue, newValue in
                    if oldValue && !newValue {
                        // Character sheet was dismissed, refresh data
                        refreshDataModel()
                    }
                }
                .onReceive(NotificationCenter.default.publisher(for: NSNotification.Name("RefreshCharacterData"))) { _ in
                    print("==== RECEIVED NOTIFICATION TO REFRESH CHARACTER DATA ====")
                    
                    // Let's double-check the data is available in the database before refreshing
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                        do {
                            let count = try context.fetch(FetchDescriptor<Character>()).count
                            print("Current character count before refresh: \(count)")
                        } catch {
                            print("Error checking characters: \(error)")
                        }
                        refreshDataModel()
                    }
                }
            }
        }
        // Sheet for adding a new character
        .sheet(isPresented: $isShowingAddCharacter) {
            NavigationStack {
                AddCharacterView(character: nil)
            }
        }
        // Sheet for editing an existing character - using item presentation for reliability
        .sheet(item: $selectedCharacter) { character in
            NavigationStack {
                AddCharacterView(character: character)
            }
        }
    }
    
    // Custom Search Bar View
    struct SearchBar: View {
        @Binding var text: String
        @FocusState private var isSearchFocused: Bool
        
        private func insertTextAtCursor(_ text: String) {
            if isSearchFocused {
                self.text.append(text)
            }
        }
        
        var body: some View {
            HStack {
                Image(systemName: "magnifyingglass")
                    .foregroundColor(.secondary)
                
                TextField("Search by name, set, or skill", text: $text)
                    .autocorrectionDisabled()
                    .focused($isSearchFocused)
                    .submitLabel(.search)
                    .onSubmit {
                        isSearchFocused = false
                    }
                
                if isSearchFocused {
                    Button("Done") {
                        isSearchFocused = false
                    }
                    .foregroundColor(.blue)
                }
                
                if !text.isEmpty {
                    Button(action: {
                        text = ""
                    }) {
                        Image(systemName: "xmark.circle.fill")
                            .foregroundColor(.secondary)
                    }
                }
            }
            .padding(8)
            .background(Color(.systemGray6))
            .cornerRadius(10)
            .onTapGesture {
                // This helps with tapping on the search bar background to focus
                if !isSearchFocused {
                    isSearchFocused = true
                }
            }
            .overlay(
                // Invisible button that covers the entire screen when search is active
                // to enable tapping outside to dismiss
                Group {
                    if isSearchFocused {
                        GeometryReader { _ in
                            Button("") {
                                isSearchFocused = false
                            }
                            .buttonStyle(.plain)
                            .frame(maxWidth: .infinity, maxHeight: .infinity)
                            .background(Color.clear)
                        }
                        .ignoresSafeArea()
                    }
                }
            )
            .keyboardToolbar(
                onInsertText: { insertTextAtCursor($0) },
                onDone: { isSearchFocused = false }
            )
        }
    }
    
    private func refreshDataModel() {
        // For debugging purposes
        let allSkills = (try? context.fetch(FetchDescriptor<Skill>())) ?? []
        let skillsWithCharacters = allSkills.filter { $0.characters != nil && !$0.characters!.isEmpty }
        let orphanedSkills = allSkills.filter { $0.characters == nil || $0.characters!.isEmpty }
        
        debugMessage = """
        Total skills: \(allSkills.count)
        Skills with characters: \(skillsWithCharacters.count)
        Orphaned skills: \(orphanedSkills.count)
        """
        
        // First make sure any changes are saved
        do {
            try context.save()
        } catch {
            print("Error saving context before fetch: \(error)")
        }
        
        // Always fetch characters to ensure we have the latest data
        do {
            var descriptor = FetchDescriptor<Character>()
            descriptor.sortBy = [SortDescriptor(\.name)]
            
            // Reset modelContext to make sure we have fresh data
            context.processPendingChanges()
            
            // Fetch characters from database
            var fetchedCharacters = try context.fetch(descriptor)
            
            // Sort favorites to the top manually
            fetchedCharacters.sort { (char1, char2) -> Bool in
                if char1.isFavorite && !char2.isFavorite {
                    return true
                } else if !char1.isFavorite && char2.isFavorite {
                    return false
                } else {
                    return char1.name.localizedCaseInsensitiveCompare(char2.name) == .orderedAscending
                }
            }
            
            characters = fetchedCharacters
            
            print("Fetched \(characters.count) characters from context \(context)")
            
            // If characters is empty, try again after a brief delay
            if characters.isEmpty {
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                    self.retryFetchCharacters()
                }
            }
        } catch {
            print("Error fetching characters: \(error)")
            characters = []
        }
    }
    
    private func retryFetchCharacters() {
        do {
            var descriptor = FetchDescriptor<Character>()
            descriptor.sortBy = [SortDescriptor(\.name)]
            
            // Fetch characters from database
            var fetchedCharacters = try context.fetch(descriptor)
            
            // Sort favorites to the top manually
            fetchedCharacters.sort { (char1, char2) -> Bool in
                if char1.isFavorite && !char2.isFavorite {
                    return true
                } else if !char1.isFavorite && char2.isFavorite {
                    return false
                } else {
                    return char1.name.localizedCaseInsensitiveCompare(char2.name) == .orderedAscending
                }
            }
            
            characters = fetchedCharacters
            
            print("Retry fetch: \(characters.count) characters")
        } catch {
            print("Error in retry fetch: \(error)")
            characters = []
        }
    }
    
    private func createTestCharacter() {
        // Create a test character directly
        let testCharacter = Character(
            name: "MANUAL TEST CHARACTER \(Date().timeIntervalSince1970)", 
            set: "Test Set", 
            notes: "Test Notes",
            isFavorite: false,
            blueSkills: ["Test Blue Skill"],
            orangeSkills: ["Test Orange Skill"],
            redSkills: ["Test Red Skill"]
        )
        
        // Insert and save
        context.insert(testCharacter)
        do {
            try context.save()
            print("Test character saved successfully")
            refreshDataModel()
        } catch {
            print("Error saving test character: \(error)")
        }
    }
    
    private func toggleFavorite(_ character: Character) {
        character.isFavorite.toggle()
        
        // Save changes
        do {
            try context.save()
            // Refresh the list to update sorting
            refreshDataModel()
        } catch {
            print("Error toggling favorite status: \(error)")
        }
    }
    
    // The wipe functions have been moved to HeaderView.swift
}

// Simple skill list display with full wrapping
struct SkillsWithDescriptionView: View {
    let skills: [Skill]
    
    // Group skills by color to maintain consistent blue->orange->red order
    // Preserve duplicates by using the EXACT skills array in original order
    var orderedSkillNames: String {
        // Create arrays of skills by color while maintaining EXACT order
        let blueSkills = skills.filter { $0.color == .blue }
                               .sorted { $0.position < $1.position }
        let orangeSkills = skills.filter { $0.color == .orange }
                                 .sorted { $0.position < $1.position }
        let redSkills = skills.filter { $0.color == .red }
                              .sorted { $0.position < $1.position }
        
        // Combine in proper order (blue, orange, red)
        let allOrderedSkills = blueSkills + orangeSkills + redSkills
        
        // Map to names preserving ALL entries including duplicates
        // We use enumerated to help debug position issues
        let skillNames = allOrderedSkills.enumerated().map { index, skill -> String in
            // You can uncomment this line to debug positions if needed
            // return "\(skill.name)[\(skill.position)]"
            return skill.name
        }
        
        return skillNames.joined(separator: ", ")
    }
    
    var body: some View {
        // Show the skill names in proper color order with wrapping
        Text(orderedSkillNames)
            .font(.caption)
            .foregroundColor(.secondary)
            .fixedSize(horizontal: false, vertical: true) // Ensure proper wrapping
    }
}

#Preview {
    ContentView()
        .environmentObject(AppViewModel())
}


----- FILE: /Users/steve/Library/Mobile Documents/com~apple~CloudDocs/AppProjects/ActionTracker/ActionTracker/Tips.swift -----
//
//  Tips.swift
//  ActionTracker
//
//  Created by Stephen Parker on 4/3/25.
//

import Foundation
import TipKit

struct EndTurnTip: Tip {
    var title = Text("End Turn")
    
    var message: Text? = Text("Tap here to reset all actions for the current turn.")
}

struct AddActionTip: Tip {
    var title = Text("Add Action")
    
    var message: Text? = Text("Tap here to add a new action.")
}


----- FILE: /Users/steve/Library/Mobile Documents/com~apple~CloudDocs/AppProjects/ActionTracker/ActionTracker/ActiveSkillsView.swift -----
//
//  ActiveSkillsView.swift
//  ActionTracker
//
//  Created by Stephen Parker on 4/27/25.
//

import SwiftUI
import SwiftData
import Observation

struct ActiveSkillsView: View {
    var character: Character
    var experience: Int
    @Binding var showSkillManager: Bool
    @State private var isExpanded: Bool = true // Controls whether skills are shown or hidden
    
    // Create a cache of tagged skills to improve performance
    private var taggedSkills: [(id: String, name: String)] {
        // Combine skills with their type tags
        let blueSkills = character.activeBlueSkills.map { (id: "blue_\($0)", name: $0) }
        let orangeSkills = character.activeOrangeSkills.map { (id: "orange_\($0)", name: $0) }
        let redSkills = character.activeRedSkills.map { (id: "red_\($0)", name: $0) }
        
        return blueSkills + orangeSkills + redSkills
    }
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            // Header with title, toggle button and manage button
            HStack {
                Button(action: {
                    withAnimation(.spring(duration: 0.3)) {
                        isExpanded.toggle()
                    }
                }) {
                    HStack(spacing: 4) {
                        Image(systemName: isExpanded ? "chevron.down" : "chevron.right")
                            .font(.caption)
                            .foregroundColor(.primary)
                        
                        Text("Active Skills:")
                            .font(.headline)
                    }
                }
                .buttonStyle(.plain)
                
                if !isExpanded && !character.allActiveSkills().isEmpty {
                    // When collapsed, show count of active skills
                    Text("\(taggedSkills.count)")
                        .font(.caption)
                        .foregroundColor(.white)
                        .lineLimit(1)
                        .padding(.horizontal, 12)
                        .padding(.vertical, 4)
                        .background(
                            Capsule()
                                .fill(.green)
                        )
                        .frame(minWidth: 40)
                }
                
                Spacer()
                
                Button("Manage") {
                    showSkillManager = true
                }
                .buttonStyle(.bordered)
            }
            
            // Only show the skills content when expanded
            if isExpanded {
                // Simple, clean skills display
                if character.allActiveSkills().isEmpty {
                    Text("No active skills for \(character.name)")
                        .foregroundColor(.secondary)
                        .padding(.vertical, 4)
                } else {
                    // LazyVGrid layout for skills with automatic columns
                    let columns = [
                        GridItem(.adaptive(minimum: 80, maximum: 160), spacing: 6)
                    ]
                    
                    LazyVGrid(columns: columns, alignment: .leading, spacing: 6) {
                        // Render all skills with their proper color
                        ForEach(taggedSkills, id: \.id) { skill in
                            if skill.id.hasPrefix("blue_") {
                                SkillPill(text: skill.name, color: .skillBlue)
                            } else if skill.id.hasPrefix("orange_") {
                                SkillPill(text: skill.name, color: .skillOrange)
                            } else { // red skills
                                SkillPill(text: skill.name, color: .skillRed)
                            }
                        }
                    }
                }
            }
        }
        .padding(.horizontal, 12)
        .padding(.vertical, 8)
        .frame(maxWidth: .infinity) // Ensure the VStack takes full available width
        .background(
            RoundedRectangle(cornerRadius: 8)
                .strokeBorder(Color.gray.opacity(0.3), lineWidth: 1)
        )
    }
}

// No longer needed as we're using FlowLayout directly

// Single skill pill
struct SkillPill: View {
    var text: String
    var color: Color
    
    var body: some View {
        Text(text)
            .font(.caption)
            .foregroundColor(.white)
            .lineLimit(1)
            .padding(.horizontal, 8)
            .padding(.vertical, 4)
            .frame(maxWidth: .infinity, alignment: .center)
            .background(
                Capsule()
                    .fill(color)
            )
    }
}

// Flow layout to handle multiple lines of skill pills
struct FlowLayout: Layout {
    var spacing: CGFloat = 6
    
    func sizeThatFits(proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) -> CGSize {
        let containerWidth = proposal.width ?? .infinity
        
        var height: CGFloat = 0
        var width: CGFloat = 0
        var lineHeight: CGFloat = 0
        var lineWidth: CGFloat = 0
        
        for subview in subviews {
            let size = subview.sizeThatFits(.unspecified)
            
            if lineWidth + size.width > containerWidth {
                // Start a new line
                width = max(width, lineWidth)
                height += lineHeight + spacing
                lineWidth = size.width
                lineHeight = size.height
            } else {
                // Add to the current line
                lineWidth += size.width + (lineWidth > 0 ? spacing : 0)
                lineHeight = max(lineHeight, size.height)
            }
        }
        
        // Account for the last line
        width = max(width, lineWidth)
        height += lineHeight
        
        return CGSize(width: width, height: height)
    }
    
    func placeSubviews(in bounds: CGRect, proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) {
        let containerWidth = bounds.width
        
        var lineX: CGFloat = bounds.minX
        var lineY: CGFloat = bounds.minY
        var lineHeight: CGFloat = 0
        
        for subview in subviews {
            let size = subview.sizeThatFits(.unspecified)
            
            // Check if we need to start a new line
            if lineX + size.width > containerWidth {
                lineX = bounds.minX
                lineY += lineHeight + spacing
                lineHeight = 0
            }
            
            // Place the view
            subview.place(at: CGPoint(x: lineX, y: lineY), proposal: ProposedViewSize(size))
            
            // Update line information
            lineX += size.width + spacing
            lineHeight = max(lineHeight, size.height)
        }
    }
}


----- FILE: /Users/steve/Library/Mobile Documents/com~apple~CloudDocs/AppProjects/ActionTracker/ActionTracker/ArrayExtension.swift -----
//
//  ArrayExtension.swift
//  ActionTracker
//
//  Created by Stephen Parker on 4/11/25.
//

import SwiftUI
import SwiftData

extension Array {
    subscript(safe index: Int) -> Element? {
        indices.contains(index) ? self[index] : nil
    }
}

// Color functions moved to SkillColorExtension.swift


----- FILE: /Users/steve/Library/Mobile Documents/com~apple~CloudDocs/AppProjects/ActionTracker/ActionTracker/ActionView.swift -----
//
//  ActionView.swift
//  ActionTracker
//
//  Created by Stephen Parker on 4/12/25.
//

import SwiftUI
import SwiftData
import TipKit

struct ActionView: View {
    // Central app state model
    @EnvironmentObject private var appViewModel: AppViewModel
    @Environment(\.dismiss) var dismiss
    @Binding var actionItems: [ActionItem]
    @Binding var timerIsRunning: Bool
    @State private var showActions: Bool = false
    @State private var trayContinuation: CheckedContinuation<ActionItem?, Never>? = nil
    @State private var addBounce: Bool = false
    @State private var shouldRotate: Bool = false
    @State private var showBulkXPInput: Bool = false
    @State private var bulkXPAmount: String = ""
    @State var duration: String = ""
    
    var availableActions: Int {
        actionItems.filter { !$0.isUsed }.count
    }
    
    var actionActions: Int {
        actionItems.filter { $0.label.hasPrefix("Action") }.count
    }

    func waitForTraySelection() async -> ActionItem? {
        await withCheckedContinuation { continuation in
            trayContinuation = continuation
            showActions = true
        }
    }

    var body: some View {
        VStack {
            // Header with character selector and available actions counter
            HStack {
                // Character Selection Button
                Button(action: {
                    appViewModel.showCharacterPicker = true
                }) {
                    HStack {
                        if let character = appViewModel.selectedCharacter, character.isFavorite {
                            Image(systemName: "star.fill")
                                .foregroundColor(.yellow)
                                .font(.caption)
                        }
                        Image(systemName: "person.fill")
                        Text(appViewModel.selectedCharacter?.name ?? "Select Character")
                            .lineLimit(1)
                            .truncationMode(.tail)
                    }
                    .padding(.vertical, 6)
                    .padding(.horizontal, 10)
                    .background(
                        RoundedRectangle(cornerRadius: 8)
                            .strokeBorder(Color.blue.opacity(0.5), lineWidth: 1)
                    )
                }
                
                Spacer()
                
                Text("Actions Available: \(availableActions)")
                    .font(.headline)
            }
            .padding(.horizontal)
            
            // List showing each action with identity for efficient updates
            List {
                ForEach(actionItems.indices, id: \.self) { index in
                    HStack {
                        Text(actionItems[index].label)
                        
                        Spacer()
                        
                        Button(action: {
                            actionItems[index].isUsed.toggle()
                        }, label: {
                            Image(systemName: actionItems[index].isUsed ? "checkmark.square.fill" : "square")
                                .font(.title)
                        })
                        .buttonStyle(BorderlessButtonStyle())
                    }
                    // Use id to ensure proper identification for ForEach
                    .id("action_\(index)_\(actionItems[index].label)")
                    // Enable swipe-to-delete only for actions beyond the first three
                    .swipeActions(edge: .trailing, allowsFullSwipe: true) {
                        if index >= 3 {
                            Button(role: .destructive) {
                                actionItems.remove(at: index)
                            } label: {
                                Label("Delete", systemImage: "trash")
                            }
                        }
                    }
                }
            }
            .listStyle(PlainListStyle())
            .task {
                try? Tips.configure()
            }
            
            // Active Skills Display
            if let character = appViewModel.selectedCharacter {
                ActiveSkillsView(
                    character: character,
                    experience: appViewModel.experience,
                    showSkillManager: $appViewModel.showSkillManager
                )
                .padding(.horizontal)
                .padding(.bottom, 6) // Add space between skills and experience section
            } else {
                // Simple placeholder when no character selected
                VStack(alignment: .leading) {
                    HStack {
                        Text("Active Skills:")
                            .font(.headline)
                        Spacer()
                    }
                    Text("No character selected")
                        .foregroundColor(.secondary)
                }
                .padding(.horizontal)
                .padding(.vertical)
                .background(
                    RoundedRectangle(cornerRadius: 8)
                        .strokeBorder(Color.gray.opacity(0.3), lineWidth: 1)
                        .padding(.horizontal, 10)
                )
                .padding(.bottom, 6) // Add space between message and experience section
            }
            
            // Experience tracking and controls
            VStack(spacing: 12) {
                // Experience level indicator
                ZStack {
                    // ULTRA banner (only when in ultra mode - experience > 43)
                    if appViewModel.isUltraMode() {
                        // Calculate which Ultra cycle we're in (0-based)
                        let ultraCycle = ((appViewModel.experience - 1) / 43)
                        
                        // First Ultra cycle (ultraCycle = 1) shows just "ULTRA"
                        // Second Ultra cycle (ultraCycle = 2) shows "ULTRA X"
                        // Third Ultra cycle (ultraCycle = 3) shows "ULTRA XX" etc.
                        let xCount = max(0, ultraCycle - 1)  // No X's for first Ultra
                        let ultraText = xCount > 0 ? "ULTRA " + String(repeating: "X", count: xCount) : "ULTRA"
                        
                        Text(ultraText)
                            .font(.system(size: 16, weight: .black))
                            .foregroundColor(.white)
                            .padding(.vertical, 4)
                            .padding(.horizontal, 11)
                            .background(
                                RoundedRectangle(cornerRadius: 8)
                                    .fill(Color.red)
                            )
                            .fixedSize(horizontal: true, vertical: false)
                            .frame(minWidth: 80)
                    }
                    HStack {
                        VStack(alignment: .leading, spacing: 2) {
                            Text("Level: \(appViewModel.getLevelLabel())")
                                .font(.headline)
                                .foregroundColor(appViewModel.getExperienceColor())
                        }
                        .padding(.horizontal)
                        
                        Spacer()
                        
                        VStack(alignment: .trailing, spacing: 2) {
                            Text("XP: \(appViewModel.getCurrentBaseLevel())/43")
                                .font(.headline)
                                .foregroundColor(appViewModel.getExperienceColor())
                        }
                        .padding(.horizontal)
                    }
                    .padding(.vertical, 8)
                    .frame(maxWidth: .infinity) // Ensure same width as skills section
                    .background(
                        RoundedRectangle(cornerRadius: 8)
                            .strokeBorder(appViewModel.getExperienceColor(), lineWidth: 2)
                            .padding(.horizontal, 8)
                    )
                }
                
                // Experience stepper
                HStack {
                    Text("Experience:")
                        .font(.headline)
                        .foregroundColor(.primary)
                    
                    Spacer()
                    
                    Button(action: {
                        bulkXPAmount = ""
                        showBulkXPInput = true
                    }) {
                        Image(systemName: "plus.square.fill")
                            .foregroundColor(appViewModel.getExperienceColor())
                            .font(.system(size: 22))
                    }
                    .padding(.trailing, 4)
                    .systemTrayView($showBulkXPInput) {
                        KeyPadView()
                    }
                    
                    Stepper(value: Binding(
                        get: { appViewModel.experience },
                        set: { appViewModel.updateExperience($0) }
                    ), in: 0...Int.max, step: 1) {
                        Text("\(appViewModel.experience)")
                            .foregroundColor(appViewModel.getExperienceColor())
                            .fontWeight(.bold)
                    }
                }
                .padding(.horizontal)
                .padding(.top, 8)
                
                // Button controls
                HStack {
                    Spacer()
                    
                    Button(action: {
                        Task {
                            if let newAction = await waitForTraySelection() {
                                var action = newAction
                                if action.label == "Action" {
                                    action.label = "Action \(actionActions + 1)"
                                }
                                actionItems.append(action)
                                renumberActionItems()
                                addBounce.toggle()
                            }
                        }
                    }, label: {
                        Image(systemName: "plus.circle.fill")
                            .symbolEffect(.bounce, value: addBounce)
                            .fontWeight(.light)
                            .font(.system(size:56))
                    })
                    .popoverTip(AddActionTip(), arrowEdge: .top)
                    .padding()
                    
                    Spacer()
                    
                    Button(action: {
                        shouldRotate.toggle()
                        for index in actionItems.indices {
                            actionItems[index].isUsed = false
                        }
                    }, label: {
                        if #available(iOS 18.0, *) {
                            Image(systemName: "arrow.trianglehead.2.clockwise.rotate.90.circle.fill")
                                .symbolEffect(.rotate.byLayer, options: .nonRepeating, value: shouldRotate)
                                .fontWeight(.light)
                                .font(.system(size:56))
                        } else {
                            Image(systemName: "arrow.trianglehead.2.clockwise.rotate.90.circle.fill")
                                .symbolEffect(.bounce, options: .nonRepeating, value: shouldRotate)
                                .fontWeight(.light)
                                .font(.system(size:56))
                        }
                    })
                    .popoverTip(EndTurnTip(), arrowEdge: .top)
                    .padding(.horizontal)
                    
                    Spacer()
                }
            }
        }
        .sheet(isPresented: $appViewModel.showCharacterPicker) {
            CharacterPickerView()
        }
        .sheet(isPresented: $appViewModel.showSkillManager) {
            if let character = appViewModel.selectedCharacter {
                SkillManagerView(
                    character: character,
                    experience: appViewModel.experience
                )
            }
        }
        .systemTrayView($showActions) {
            TrayView { selectedAction in
                trayContinuation?.resume(returning: selectedAction)
                trayContinuation = nil
                showActions = false
            }
        }
        .onReceive(NotificationCenter.default.publisher(for: NSNotification.Name("ResetExperience"))) { _ in
            // Reset all experience tracking when notification is received
            appViewModel.resetExperience()
            
            // Reset all actions to unused state
            for index in actionItems.indices {
                actionItems[index].isUsed = false
            }
            
            // Also clear the selected character
            appViewModel.clearSelectedCharacter()
        }
    }
    
    // Renumber action items to maintain a clean sequence 
    func renumberActionItems() {
        var expectedNumber = 1
        for index in actionItems.indices where actionItems[index].label.hasPrefix("Action") {
            let components = actionItems[index].label.split(separator: " ")
            if components.count > 1, let number = Int(components[1]), number != expectedNumber {
                actionItems[index].label = "Action \(expectedNumber)"
            } else if components.count == 1 {
                actionItems[index].label = "Action \(expectedNumber)"
            }
            expectedNumber += 1
        }
    }
    
    /// View for keyboard
    @ViewBuilder
    func KeyPadView() -> some View {
        VStack(spacing: 12) {
            HStack {
                Text("Bulk AP")
                    .font(.title2)
                    .fontWeight(.semibold)
                
                Spacer(minLength: 0)
                
                Button {
                    withAnimation(.bouncy) {
                        showBulkXPInput = false
                    }
                } label: {
                    Image(systemName: "xmark.circle.fill")
                        .font(.title)
                        .foregroundStyle(Color.gray, Color.primary.opacity(0.1))
                }
            }
            .padding(.bottom, 10)
            
            VStack(spacing: 6) {
                Text(duration.isEmpty ? "0" : duration)
                    .font(.system(size: 60, weight: .black))
                    .contentTransition(.numericText())
                
                Text("Action Points")
                    .font(.caption)
                    .foregroundStyle(.gray)
            }
            .padding(.vertical, 20)
            
            /// Custom Keypad View
            LazyVGrid(columns: Array(repeating: GridItem(), count: 3), spacing: 15) {
                ForEach(keypadValues) { keyValue in
                    if keyValue.value == 0 {
                        Spacer()
                    }
                    
                    Group {
                        if keyValue.isBack {
                            Image(systemName: keyValue.title)
                        } else {
                            Text(keyValue.title)
                        }
                    }
                    .font(.title2)
                    .fontWeight(.semibold)
                    .frame(maxWidth: .infinity)
                    .frame(height: 60)
                    .contentShape(.rect)
                    .onTapGesture {
                        withAnimation(.snappy) {
                            if keyValue.isBack {
                                if !duration.isEmpty {
                                    duration.removeLast()
                                }
                            } else if duration.count < 2 {
                                print(duration)
                                duration.append(keyValue.title)
                            }
                        }
                    }
                }
            }
            .padding(.horizontal, -15)
            
            Button {
                withAnimation(.bouncy) {
                    if let amount = Int(duration), amount >= 1, amount <= 99 {
                        appViewModel.updateExperience(appViewModel.experience + amount)
                    }
                    duration = ""
                    showBulkXPInput = false
                }
            } label: {
                Text("Continue")
                    .fontWeight(.semibold)
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, 15)
                    .foregroundStyle(.white)
                    .background(.blue, in: .capsule)
            }
        }
        .padding(20)
    }
}

#Preview {
    ContentView()
        .environmentObject(AppViewModel())
}


----- FILE: /Users/steve/Library/Mobile Documents/com~apple~CloudDocs/AppProjects/ActionTracker/ActionTracker/SearchBar.swift -----
//
//  SearchBar.swift
//  ActionTracker
//
//  Created by Stephen Parker on 4/29/25.
//

import SwiftUI

struct SearchBar: View {
    @Binding var text: String
    @FocusState private var isSearchFocused: Bool
    
    private func insertTextAtCursor(_ text: String) {
        if isSearchFocused {
            self.text.append(text)
        }
    }
    
    var body: some View {
        HStack {
            Image(systemName: "magnifyingglass")
                .foregroundColor(.secondary)
            
            TextField("Search by name, set, or skill", text: $text)
                .autocorrectionDisabled()
                .focused($isSearchFocused)
                .submitLabel(.search)
                .onSubmit {
                    isSearchFocused = false
                }
            
            if !text.isEmpty {
                Button(action: {
                    text = ""
                }) {
                    Image(systemName: "xmark.circle.fill")
                        .foregroundColor(.secondary)
                }
            }
        }
        .padding(8)
        .background(Color(.systemGray6))
        .cornerRadius(10)
        .onTapGesture {
            // This helps with tapping on the search bar background to focus
            if !isSearchFocused {
                isSearchFocused = true
            }
        }
        .overlay(
            // Invisible button that covers the entire screen when search is active
            // to enable tapping outside to dismiss
            Group {
                if isSearchFocused {
                    GeometryReader { _ in
                        Button("") {
                            isSearchFocused = false
                        }
                        .buttonStyle(.plain)
                        .frame(maxWidth: .infinity, maxHeight: .infinity)
                        .background(Color.clear)
                    }
                    .ignoresSafeArea()
                }
            }
        )
        .keyboardToolbar(
            onInsertText: { insertTextAtCursor($0) },
            onDone: { isSearchFocused = false }
        )
    }
}


----- FILE: /Users/steve/Library/Mobile Documents/com~apple~CloudDocs/AppProjects/ActionTracker/ActionTracker/TrayView.swift -----
//
//  TrayView.swift
//  ActionTracker
//
//  Created by Stephen Parker on 4/2/25.
//

import SwiftUI


struct TrayView: View {
    @State private var selectedAction: Action?
    @Environment(\.dismiss) var dismiss
    
    let onActionSelected: (ActionItem?) -> Void
    
    var body: some View {
        VStack(spacing: 20) {
            ZStack {
                VStack(spacing: 12) {
                    HStack {
                        Text("Choose Your Action")
                            .font(.title2)
                            .fontWeight(.semibold)
                        
                        Spacer(minLength: 0)
                        
                        Button {
                            /// Dismissing Sheet
                            onActionSelected(nil)
                            dismiss()
                        } label: {
                            Image(systemName: "xmark.circle.fill")
                                .font(.title)
                                .foregroundStyle(Color.gray, Color.primary.opacity(0.1))
                        }
                    }
                    .padding(.bottom, 10)
                    
                    /// Custom Checkbox Menu
                    ForEach(actions) { action in
                        let isSelected: Bool = selectedAction?.id == action.id
                        
                        HStack(spacing: 10) {
                            Image(systemName: action.image)
                                .font(.title)
                                .frame(width: 40)
                            
                            Text(action.title)
                                .fontWeight(.semibold)
                            
                            Spacer(minLength: 0)
                            
                            Image(systemName: isSelected ? "checkmark.circle.fill" : "circle.fill")
                                .font(.title)
                                .contentTransition(.symbolEffect)
                                .foregroundStyle(isSelected ? Color.blue : Color.gray.opacity(0.2))
                        }
                        .padding(.vertical, 6)
                        .contentShape(.rect)
                        .onTapGesture {
                            withAnimation(.snappy) {
                                selectedAction = isSelected ? nil : action
                            }
                        }
                    }
                }
            }
            .compositingGroup()
            
            /// Continue Button
            Button {
                if let action = selectedAction {
                    onActionSelected(ActionItem(id: UUID(), label: action.title, isUsed: false))
                } else {
                    onActionSelected(nil)
                }
                dismiss()
            } label: {
                Text("Continue")
                    .fontWeight(.semibold)
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, 15)
                    .foregroundStyle(.white)
                    .background(.blue, in: .capsule)
            }
            .disabledWithOpacity(selectedAction == nil ? true : false)
            .padding(.top, 15)
        }
        .padding(20)
        .onDisappear {
            if selectedAction == nil {
                onActionSelected(nil)
            }
        }
    }
}


----- FILE: /Users/steve/Library/Mobile Documents/com~apple~CloudDocs/AppProjects/ActionTracker/ActionTracker/HeaderView.swift -----
//
//  HeaderView.swift
//  ActionTracker
//
//  Created by Stephen Parker on 4/12/25.
//

import SwiftUI
import SwiftData
import UniformTypeIdentifiers
import UIKit
import Foundation

// Removed menu tracking

enum ViewType {
    case action
    case character
    case campaign
}

struct HeaderView: View {
    @Binding var keepAwake: Bool
    @Binding var currentView: ViewType
    @Binding var actionItems: [ActionItem]
    @Binding var isShowingAddCharacter: Bool
    @State private var addWiggle: Bool = false
    @State private var showingSkillLibrary: Bool = false
    
    // Timer related state - simplified
    @State private var timerStartDate: Date? = nil
    @State private var elapsedTime: TimeInterval = 0
    @State private var showResetConfirmation: Bool = false
    @State private var showStopConfirmation: Bool = false
    @State private var displayPaused: Bool = false
    
    // Binding to share timer state with parent and siblings
    @Binding var timerRunningBinding: Bool
    
    // Direct access to AppViewModel
    @EnvironmentObject private var appViewModel: AppViewModel
    
    @Query(sort: \Character.name) var characters: [Character]
    @Environment(\.modelContext) private var context
    
    var title: String {
        switch currentView {
        case .action:
            return "Actions"
        case .character:
            return "Characters"
        case .campaign:
            return "Campaigns"
        }
    }
    
    // Format the elapsed time - hours and minutes only
    var formattedElapsedTime: String {
        let hours = Int(elapsedTime) / 3600
        let minutes = (Int(elapsedTime) % 3600) / 60
        
        // Always show hours and minutes only (no seconds)
        return String(format: "%02d:%02d", hours, minutes)
    }
    
    var body: some View {
        HStack {
            Text(title)
                .font(.largeTitle.bold())
                
            Spacer()
            
            // Timer display - only show in action view
            if currentView == .action {
                HStack(spacing: 4) {
                    // Show icon based on timer state
                    if timerRunningBinding {
                        if displayPaused {
                            // Paused state - show pause icon
                            Image(systemName: "pause.fill")
                                .font(.caption)
                                .foregroundColor(.secondary)
                        } else {
                            Image(systemName: "play.fill")
                                .font(.caption)
                                .foregroundColor(.green)
                        }
                    } else if timerStartDate != nil {
                        // Stopped state
                        Image(systemName: "stop.fill")
                            .font(.caption)
                            .foregroundColor(.red)
                    }
                    
                    // Timer text with simple styling based on state
                    Text(formattedElapsedTime)
                        .font(.title2.monospacedDigit())
                        .foregroundColor(getTimerTextColor())
                        .contentTransition(.numericText())
                        .animation(displayPaused ? nil : .easeInOut, value: elapsedTime)
                }
                .padding(8)
                .background(
                    RoundedRectangle(cornerRadius: 8)
                        .fill(getTimerBackgroundColor())
                        .animation(.easeInOut(duration: 0.2), value: timerRunningBinding)
                        .animation(.easeInOut(duration: 0.2), value: displayPaused)
                )
                .overlay(
                    RoundedRectangle(cornerRadius: 8)
                        .strokeBorder(getTimerBorderColor(), lineWidth: 1.5)
                        .animation(.easeInOut(duration: 0.2), value: timerRunningBinding)
                        .animation(.easeInOut(duration: 0.2), value: displayPaused)
                )
                .onTapGesture {
                    // Only allow pause/unpause when timer is running
                    if timerRunningBinding {
                        withAnimation {
                            displayPaused.toggle()
                        }
                        
                        // When unpausing, update immediately
                        if !displayPaused {
                            updateElapsedTime()
                        }
                    }
                }
            }
            
            Spacer()
            
            // Ensure skill names are always normalized when view appears
            .onAppear {
                normalizeSkillNamesIfNeeded()
            }
            
            Menu {
                    Button {
                        keepAwake.toggle()
                        UIApplication.shared.isIdleTimerDisabled = keepAwake
                    } label: {
                        Label(keepAwake ? "Disable Keep Awake" : "Enable Keep Awake", systemImage: keepAwake ? "moon" : "sun.max")
                    }
                    .onAppear {
                        UIApplication.shared.isIdleTimerDisabled = keepAwake
                    }

                    Button {
                        withAnimation(.snappy) {
                            currentView = .action
                        }
                    } label: {
                        Label(
                            "Switch to Actions",
                            systemImage: "checkmark.seal.fill"
                        )
                    }
                
                    Button {
                        withAnimation(.snappy) {
                            currentView = .character
                        }
                    } label: {
                        Label(
                            "Switch to Characters",
                            systemImage: "person.2.fill"
                        )
                    }

                    Button {
                        withAnimation(.snappy) {
                            currentView = .campaign
                        }
                    } label: {
                        Label(
                            "Switch to Campaigns",
                            systemImage: "list.bullet.clipboard"
                        )
                    }
                
                    switch currentView {
                    case .action:
                        Divider ()
                        
                        Button(role: .destructive) {
                            // Update mission notes before resetting
                            updateMissionNotes()
                            resetActions()
                        } label: {
                            HStack {
                                Text("Reset Actions")
                                Image(systemName: "trash")
                            }
                            .foregroundColor(.red)
                        }
                    case .character:
                        Divider()
                        
                        Button {
                            isShowingAddCharacter = true
                            addWiggle.toggle()
                        } label: {
                            HStack {
                                Text("Add Character")
                                Image(systemName: "plus.circle.fill")
                                    .symbolEffect(.wiggle, value: addWiggle)
                            }
                        }
                        
                        Button {
                            showingSkillLibrary = true
                        } label: {
                            Text("Skill Library")
                            Image(systemName: "book.fill")
                        }
                    case .campaign:
                        Divider()
                        
                        Button(role: .destructive) {
                            withAnimation(.easeOut(duration: 30)) {
                                wipeAllCampaigns()
                            }
                        } label: {
                            HStack {
                                Text("Reset Campaigns")
                                Image(systemName: "trash")
                            }
                            .foregroundColor(.red)
                        }
                    }
                Divider()
                
                Menu {
                    Button {
                        startTimer()
                    } label: {
                        Label(
                            "Start",
                            systemImage: "timer"
                        )
                    }
                    .disabled(timerRunningBinding)
                    
                    Button {
                        showResetConfirmation = true
                    } label: {
                        Label(
                            "Reset",
                            systemImage: "clock.arrow.trianglehead.2.counterclockwise.rotate.90"
                        )
                    }
                    .disabled(timerStartDate == nil)
                    
                    Button {
                        showStopConfirmation = true
                    } label: {
                        Label(
                            "Stop",
                            systemImage: "exclamationmark.arrow.trianglehead.counterclockwise.rotate.90"
                        )
                    }
                    .disabled(!timerRunningBinding)
                } label: {
                    Text("Timer")
                }
                
                Divider()
                
                Menu {
                    // Import options
                    Button {
                        importCharacters()
                    } label: {
                        Label(
                            "Import Characters",
                            systemImage: "square.and.arrow.down.fill"
                        )
                    }
                        
                    Button {
                        importSkills()
                    } label: {
                        Label(
                            "Import Skills",
                            systemImage: "square.and.arrow.down.on.square.fill"
                        )
                    }
                        
                    Divider()
                        
                    // Export options
                    Button {
                        exportCharacters()
                    } label: {
                        Label(
                            "Export Characters",
                            systemImage: "square.and.arrow.up.fill"
                        )
                    }
                        
                    Button {
                        exportSkills()
                    } label: {
                        Label(
                            "Export Skills",
                            systemImage: "square.and.arrow.up.on.square.fill"
                        )
                    }
                } label: {
                    Label(
                        "Import/Export",
                        systemImage: "square.and.arrow.up.down.fill"
                    )
                }
                    
                Divider()
                    
                Button(role: .destructive) {
                    wipeAllCharacters()
                } label: {
                    Label("Delete All Characters", systemImage: "trash.fill")
                }
                    
                Button(role: .destructive) {
                    wipeAllSkills()
                } label: {
                    Label("Delete All Skills", systemImage: "trash.fill")
                }
                    
                Button(role: .destructive) {
                    wipeAllData()
                } label: {
                    Label(
                        "Delete All Data",
                        systemImage: "exclamationmark.triangle.fill"
                    )
                }
            } label: {
                Image(systemName: "ellipsis.circle")
                    .font(.largeTitle)
                    .padding()
            }
        }
        .padding(.horizontal)
        .onAppear {
            normalizeSkillNamesIfNeeded()
        }
        .sheet(isPresented: $showingSkillLibrary) {
            SkillView()
        }
        .onChange(of: showResetConfirmation) { oldValue, newValue in
            if newValue {
                // Instead of showing dialog, immediately reset the timer
                resetTimer()
                // Immediately toggle it back to false
                showResetConfirmation = false
            }
        }
        .confirmationDialog("Stop Timer?", isPresented: $showStopConfirmation) {
            Button("Stop", role: .destructive) {
                stopTimer()
            }
            Button("Cancel", role: .cancel) {}
        } message: {
            Text("Are you sure you want to stop the timer? This will end the current game session.")
        }
        .onReceive(Timer.publish(every: 60, on: .main, in: .common).autoconnect()) { _ in
            // Update once per minute to keep timer showing the right time
            // Since we only display HH:MM, updating more frequently isn't needed
            if timerRunningBinding && !displayPaused {
                updateElapsedTime()
            }
        }
        // Also update every second in background (while not displaying)
        // This ensures we have the correct time even when paused
        .onReceive(Timer.publish(every: 10, on: .main, in: .common).autoconnect()) { _ in
            if timerRunningBinding {
                // Silent update - just calculate time but don't update display
                // This ensures when we unpause, we have the correct time
                if let startDate = timerStartDate {
                    // Store but don't display if paused
                    elapsedTime = Date().timeIntervalSince(startDate)
                }
            }
        }
        // Listen for the notification to start a new mission timer
        .onReceive(NotificationCenter.default.publisher(for: NSNotification.Name("StartNewMissionTimer"))) { _ in
            // Start a new timer for the mission
            startTimer()
        }
    }
    
    // Timer functions - simplified
    private func startTimer() {
        // Start a new timer
        timerStartDate = Date()
        timerRunningBinding = true
        displayPaused = false  // Always start with display active
        elapsedTime = 0
        updateElapsedTime()    // Initialize with proper time
    }
    
    private func resetTimer() {
        // Update mission notes before resetting, if a mission is being tracked
        updateMissionNotes()
        
        // Reset the timer to current time
        timerStartDate = Date()
        timerRunningBinding = true
        displayPaused = false  // Always reset with display active
        elapsedTime = 0
        updateElapsedTime()    // Initialize with proper time
    }
    
    private func stopTimer() {
        timerRunningBinding = false
        
        // Update mission notes instead of showing game summary
        updateMissionNotes()
    }
    
    private func updateMissionNotes() {
        print("DEBUG HeaderView: Updating mission notes, elapsed time: \(elapsedTime)")
        
        // Now using the direct EnvironmentObject reference
        let success = appViewModel.updateMissionNotes(elapsedTime: elapsedTime)
        print("DEBUG HeaderView: Update mission notes result: \(success)")
    }
    
    // Helper functions for timer display
    private func updateElapsedTime() {
        if let startDate = timerStartDate {
            elapsedTime = Date().timeIntervalSince(startDate)
        }
    }
    
    // Get the appropriate text color based on timer state
    private func getTimerTextColor() -> Color {
        if !timerRunningBinding && timerStartDate != nil {
            // Stopped state - red text
            return .red
        } else if displayPaused {
            // Paused state - grey text
            return .secondary
        } else {
            // Running state - white/primary text
            return .primary
        }
    }
    
    // Get the appropriate background color based on timer state
    private func getTimerBackgroundColor() -> Color {
        if !timerRunningBinding && timerStartDate != nil {
            // Stopped state - light red background
            return Color.red.opacity(0.1)
        } else if displayPaused {
            // Paused state - light grey background
            return Color(UIColor.secondarySystemBackground).opacity(0.3)
        } else {
            // Running state - subtle blue background
            return Color.blue.opacity(0.05)
        }
    }
    
    // Get the appropriate border color based on timer state
    private func getTimerBorderColor() -> Color {
        if !timerRunningBinding && timerStartDate != nil {
            // Stopped state - red border
            return Color.red.opacity(0.3)
        } else if displayPaused {
            // Paused state - grey border
            return Color.secondary.opacity(0.3)
        } else {
            // Running state - blue border
            return Color.blue.opacity(0.3)
        }
    }
    
    private func exportCharacters() {
        // Dictionary to track processed characters by name+set to prevent duplicates
        // Key format is "name|set" in lowercase
        var processedCharacters: [String: Character] = [:]
        
        // First pass - collect unique characters by name+set combo
        for character in characters {
            // Normalize the name and set - trim and fix all whitespace issues
            let trimmedName = character.name.trimmingCharacters(in: .whitespacesAndNewlines)
            let normalizedName = trimmedName.replacingOccurrences(of: "\\s+", with: " ", options: .regularExpression).lowercased()
            
            let trimmedSet = (character.set ?? "").trimmingCharacters(in: .whitespacesAndNewlines)
            let normalizedSet = trimmedSet.replacingOccurrences(of: "\\s+", with: " ", options: .regularExpression).lowercased()
            
            // Create a composite key for uniqueness
            let key = "\(normalizedName)|\(normalizedSet)"
            
            // If this name/set combo exists, keep the one with more information
            if let existingChar = processedCharacters[key] {
                // Treat a nil skills array as 0 skills
                let existingSkillCount = existingChar.skills?.count ?? 0
                let newSkillCount      = character.skills?.count     ?? 0
                let existingNotesLength = existingChar.notes?.count ?? 0
                let newNotesLength      = character.notes?.count     ?? 0

                // Now both are Int, so you can compare safely
                if newSkillCount > existingSkillCount ||
                   (newSkillCount == existingSkillCount && newNotesLength > existingNotesLength) {
                    processedCharacters[key] = character
                }
            } else {
                processedCharacters[key] = character
            }
        }
        
        // Generate CSV content - updated header for the new format
        var csvString = "Name,Set,Notes,Blue,Orange,Red\n"
        
        // Sort the unique characters alphabetically by name, then by set
        let uniqueCharacters = processedCharacters.values.sorted { char1, char2 in
            if char1.name.lowercased() != char2.name.lowercased() {
                return char1.name.lowercased() < char2.name.lowercased()
            } else {
                let set1 = char1.set?.lowercased() ?? ""
                let set2 = char2.set?.lowercased() ?? ""
                return set1 < set2
            }
        }
        
        // Process each unique character for CSV export
        for character in uniqueCharacters {
            // First clean up all whitespace in both name and set
            let cleanName = character.name.trimmingCharacters(in: .whitespacesAndNewlines)
                                         .replacingOccurrences(of: "\\s+", with: " ", options: .regularExpression)
            
            // Capitalize the name properly for a character (Title Case)
            let nameWords = cleanName.split(separator: " ")
            let capitalizedName = nameWords.map { $0.prefix(1).uppercased() + $0.dropFirst().lowercased() }.joined(separator: " ")
            
            // Clean up set and notes too
            let cleanSet = (character.set ?? "").trimmingCharacters(in: .whitespacesAndNewlines)
                                              .replacingOccurrences(of: "\\s+", with: " ", options: .regularExpression)
            
            let cleanNotes = (character.notes ?? "").trimmingCharacters(in: .whitespacesAndNewlines)
                                                  .replacingOccurrences(of: "\\s+", with: " ", options: .regularExpression)
            
            // Escape quotes for CSV
            let name = capitalizedName.replacingOccurrences(of: "\"", with: "\"\"") 
            let set = cleanSet.replacingOccurrences(of: "\"", with: "\"\"") 
            let notes = cleanNotes.replacingOccurrences(of: "\"", with: "\"\"") 
            
            // Group skills by color
            var blueSkills: [String] = []
            var orangeSkills: [String] = []
            var redSkills: [String] = []
            
            // Sort skills by position and group by color
            if let sortedSkills = character.skills?
                                    .sorted(by: { $0.position < $1.position }) {
                for skill in sortedSkills {
                    let normalizedName = Skill.normalizeSkillName(skill.name)

                    switch skill.color {
                    case .blue:
                        blueSkills.append(normalizedName)
                    case .orange:
                        orangeSkills.append(normalizedName)
                    case .red:
                        redSkills.append(normalizedName)
                    case .none:
                        break   // or handle missing color if needed
                    }
                }
            }
            
            // Join skills by color with semicolons and escape quotes
            let blueSkillsStr = blueSkills.joined(separator: ";").replacingOccurrences(of: "\"", with: "\"\"")
            let orangeSkillsStr = orangeSkills.joined(separator: ";").replacingOccurrences(of: "\"", with: "\"\"")
            let redSkillsStr = redSkills.joined(separator: ";").replacingOccurrences(of: "\"", with: "\"\"")
            
            // Create the CSV row with the new format
            let row = "\"\(name)\",\"\(set)\",\"\(notes)\",\"\(blueSkillsStr)\",\"\(orangeSkillsStr)\",\"\(redSkillsStr)\""
            csvString.append(row + "\n")
        }
        
        let tempURL = FileManager.default.temporaryDirectory.appendingPathComponent("characters.csv")
        do {
            try csvString.write(to: tempURL, atomically: true, encoding: .utf8)
            let activityVC = UIActivityViewController(activityItems: [tempURL], applicationActivities: nil)
            if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
               let rootVC = windowScene.windows.first?.rootViewController {
                rootVC.present(activityVC, animated: true, completion: nil)
            }
        } catch {
            print("Export failed: \(error)")
            
            // Show error alert
            let alert = UIAlertController(
                title: "Export Failed",
                message: "Failed to export characters: \(error.localizedDescription)",
                preferredStyle: .alert
            )
            alert.addAction(UIAlertAction(title: "OK", style: .default))
            
            if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
               let rootVC = windowScene.windows.first?.rootViewController {
                rootVC.present(alert, animated: true)
            }
        }
    }
    
    private func exportSkills() {
        // Fetch all skills
        let skillsDescriptor = FetchDescriptor<Skill>(sortBy: [SortDescriptor(\.name)])
        
        do {
            let allSkills = try context.fetch(skillsDescriptor)
            
            if allSkills.isEmpty {
                // Show alert if no skills to export
                let alert = UIAlertController(
                    title: "No Skills",
                    message: "There are no skills to export.",
                    preferredStyle: .alert
                )
                alert.addAction(UIAlertAction(title: "OK", style: .default))
                
                if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
                   let rootVC = windowScene.windows.first?.rootViewController {
                    rootVC.present(alert, animated: true)
                }
                return
            }
            
            // Dictionary to track processed skills by name (lowercase) to prevent duplicates
            var processedSkills: [String: Skill] = [:]
            
            // First pass - collect unique skills by lowercase name
            for skill in allSkills {
                // Clean up whitespace before normalization
                let trimmedName = skill.name.trimmingCharacters(in: .whitespacesAndNewlines)
                let cleanName = trimmedName.replacingOccurrences(of: "\\s+", with: " ", options: .regularExpression)
                let lowerName = cleanName.lowercased()
                
                // If this lowercase name exists, keep the one with more information
                if let existingSkill = processedSkills[lowerName] {
                    // Choose the one with the most information
                    if skill.skillDescription.count > existingSkill.skillDescription.count {
                        processedSkills[lowerName] = skill
                    }
                } else {
                    // First time seeing this skill name
                    processedSkills[lowerName] = skill
                }
            }
            
            // Generate CSV content
            var csvString = "Name,Description\n"
            
            // Sort the unique skills alphabetically
            let uniqueSkills = processedSkills.values.sorted { $0.name.lowercased() < $1.name.lowercased() }
            
            for skill in uniqueSkills {
                // Use normalized name to ensure consistent capitalization
                let name = Skill.normalizeSkillName(skill.name).replacingOccurrences(of: "\"", with: "\"\"")
                
                // Clean up description whitespace
                let cleanDescription = skill.skillDescription.trimmingCharacters(in: .whitespacesAndNewlines)
                                                            .replacingOccurrences(of: "\\s+", with: " ", options: .regularExpression)
                                                            .replacingOccurrences(of: "\"", with: "\"\"")
                
                let row = "\"\(name)\",\"\(cleanDescription)\""
                csvString.append(row + "\n")
            }
            
            // Write to temporary file
            let tempURL = FileManager.default.temporaryDirectory.appendingPathComponent("skills.csv")
            try csvString.write(to: tempURL, atomically: true, encoding: .utf8)
            
            // Show share sheet
            let activityVC = UIActivityViewController(activityItems: [tempURL], applicationActivities: nil)
            if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
               let rootVC = windowScene.windows.first?.rootViewController {
                rootVC.present(activityVC, animated: true, completion: nil)
            }
            
        } catch {
            print("Failed to export skills: \(error)")
            
            // Show error alert
            let alert = UIAlertController(
                title: "Export Failed",
                message: "Failed to export skills: \(error.localizedDescription)",
                preferredStyle: .alert
            )
            alert.addAction(UIAlertAction(title: "OK", style: .default))
            
            if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
               let rootVC = windowScene.windows.first?.rootViewController {
                rootVC.present(alert, animated: true)
            }
        }
    }
    
    // Static key to store the coordinator reference to prevent it from being deallocated
    private static var coordinatorKey = "com.actiontracker.skillImportCoordinatorKey"
    
    // Coordinator class for handling skill imports
    class SkillImportCoordinator: NSObject, UIDocumentPickerDelegate {
        private let modelContext: ModelContext
        
        init(modelContext: ModelContext) {
            self.modelContext = modelContext
            super.init()
        }
        
        func documentPicker(_ controller: UIDocumentPickerViewController, didPickDocumentsAt urls: [URL]) {
            guard let url = urls.first else { return }
            
            guard url.startAccessingSecurityScopedResource() else {
                print("Failed to access security-scoped resource.")
                return
            }
            
            defer { url.stopAccessingSecurityScopedResource() }
            
            do {
                // Read the CSV file
                let content = try String(contentsOf: url, encoding: .utf8)
                let rows = content.components(separatedBy: CharacterSet.newlines).dropFirst() // Skip header
                
                var importedCount = 0
                var skippedCount = 0
                
                // Process each row
                for line in rows {
                    guard !line.trimmingCharacters(in: .whitespaces).isEmpty else { continue }
                    
                    // Parse the CSV line (assuming no commas in quoted values for simplicity)
                    let columns = parseCSVLine(line)
                    guard columns.count >= 2 else { continue }
                    
                    // Clean up name and description - trim spaces and normalize internal spacing
                    let rawName = columns[0].trimmingCharacters(in: .whitespacesAndNewlines)
                    let cleanName = rawName.replacingOccurrences(of: "\\s+", with: " ", options: .regularExpression)
                    
                    let rawDescription = columns[1].trimmingCharacters(in: .whitespacesAndNewlines)
                    let cleanDescription = rawDescription.replacingOccurrences(of: "\\s+", with: " ", options: .regularExpression)
                    
                    // Skip if empty name
                    if cleanName.isEmpty { continue }
                    
                    // Check if skill with the same name (case-insensitive) already exists
                    // First normalize the name using our helper
                    let normalizedName = Skill.normalizeSkillName(cleanName)
                    
                    // For predicate, we can only use exact matching without string functions
                    var skillDescriptor = FetchDescriptor<Skill>()
                    skillDescriptor.predicate = #Predicate<Skill> { skill in 
                        skill.name == normalizedName
                    }
                    
                    do {
                        let existingSkills = try modelContext.fetch(skillDescriptor)
                        
                        if existingSkills.isEmpty {
                            // Create new skill - Note: Skill initializer will normalize the name automatically
                            let newSkill = Skill(name: cleanName, skillDescription: cleanDescription, manual: true, importedFlag: true, color: .blue)
                            modelContext.insert(newSkill)
                            importedCount += 1
                        } else {
                            // Skill already exists, skip
                            skippedCount += 1
                            
                            // Optionally update description if the existing one is empty
                            if let existingSkill = existingSkills.first, existingSkill.skillDescription.isEmpty && !cleanDescription.isEmpty {
                                existingSkill.skillDescription = cleanDescription
                            }
                        }
                    } catch {
                        print("Error checking for existing skill: \(error)")
                    }
                }
                
                // Save changes
                try modelContext.save()
                
                // Show success alert
                DispatchQueue.main.async {
                    self.showResultAlert(imported: importedCount, skipped: skippedCount)
                }
                
            } catch {
                print("Import failed: \(error)")
                
                // Show error alert
                DispatchQueue.main.async {
                    self.showErrorAlert(error: error)
                }
            }
        }
        
        private func parseCSVLine(_ line: String) -> [String] {
            var results: [String] = []
            var value = ""
            var insideQuotes = false
            
            var iterator = line.makeIterator()
            while let char = iterator.next() {
                switch char {
                case "\"":
                    insideQuotes.toggle()
                case ",":
                    if insideQuotes {
                        value.append(char)
                    } else {
                        results.append(value)
                        value = ""
                    }
                default:
                    value.append(char)
                }
            }
            results.append(value)
            return results.map { $0.replacingOccurrences(of: "\"\"", with: "\"") }
        }
        
        private func showResultAlert(imported: Int, skipped: Int) {
            let alert = UIAlertController(
                title: "Import Complete",
                message: "Successfully imported \(imported) new skills. \(skipped) existing skills were skipped.",
                preferredStyle: .alert
            )
            alert.addAction(UIAlertAction(title: "OK", style: .default))
            
            if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
               let rootVC = windowScene.windows.first?.rootViewController {
                rootVC.present(alert, animated: true)
            }
        }
        
        private func showErrorAlert(error: Error) {
            let alert = UIAlertController(
                title: "Import Failed",
                message: "Failed to import skills: \(error.localizedDescription)",
                preferredStyle: .alert
            )
            alert.addAction(UIAlertAction(title: "OK", style: .default))
            
            if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
               let rootVC = windowScene.windows.first?.rootViewController {
                rootVC.present(alert, animated: true)
            }
        }
    }
    
    private func importSkills() {
        let alert = UIAlertController(
            title: "Import Skills",
            message: """
            Import will add new skills to your library.
            Existing skills with the same name will be skipped.
            
            Make sure your CSV has this format:
            
            Name,Description
            "+1 Die: Combat","Add 1 die to combat rolls"
            "Lucky","Re-roll one failed die per turn"
            """,
            preferredStyle: .alert
        )
        
        alert.addAction(UIAlertAction(title: "Cancel", style: .cancel, handler: nil))
        alert.addAction(UIAlertAction(title: "Continue", style: .default) { _ in
            let documentPicker = UIDocumentPickerViewController(forOpeningContentTypes: [UTType.commaSeparatedText])
            documentPicker.allowsMultipleSelection = false
            
            // Using a coordinator for the document picker
            let coordinator = SkillImportCoordinator(modelContext: self.context)
            documentPicker.delegate = coordinator
            
            // Keep a reference to the coordinator to prevent it from being deallocated
            objc_setAssociatedObject(documentPicker, HeaderView.coordinatorKey, coordinator, .OBJC_ASSOCIATION_RETAIN)
            
            if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
               let rootVC = windowScene.windows.first?.rootViewController {
                rootVC.present(documentPicker, animated: true, completion: nil)
            }
        })
        
        if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
           let rootVC = windowScene.windows.first?.rootViewController {
            rootVC.present(alert, animated: true, completion: nil)
        }
    }
    
    private func importCharacters() {
        // Configure with context and completion handler
        CustomContext.shared.configure(with: context) {
            // This will be called after successful import
            print("Import completed, refreshing view...")
            
            // Important: Save the context and send a notification
            do {
                try context.save()
                print("Context saved after import")
                
                // Verify character count from the context that's using the view
                let verifyCount = try context.fetch(FetchDescriptor<Character>()).count
                print("Verified after import completion: \(verifyCount) characters in UI context")
                
                // Force refresh notification
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                    print("==== SENDING REFRESH NOTIFICATION AFTER IMPORT ====")
                    NotificationCenter.default.post(name: NSNotification.Name("RefreshCharacterData"), object: nil)
                }
            } catch {
                print("Error saving context after import: \(error)")
            }
        }
        
        let alert = UIAlertController(
            title: "Import Format",
            message: """
            Import will replace all existing characters.
            
            Make sure your CSV has this format:
            
            Name,Set,Notes,Blue,Orange,Red
            "Adam","","Special","Zombie Link","+1 To Dice Roll: Melee;Distributor","+1 Damage: Combat;+1 Free Action: Combat;Born Leader"
            
            - Blue skills are active by default
            - Orange skills can be activated at XP 19
            - Red skills can be activated at XP 43
            - Multiple skills in the same power level are separated by ";"
            """,
            preferredStyle: .alert
        )
        alert.addAction(UIAlertAction(title: "Cancel", style: .cancel, handler: nil))
        alert.addAction(UIAlertAction(title: "Continue", style: .default) { _ in
            let documentPicker = UIDocumentPickerViewController(forOpeningContentTypes: [UTType.commaSeparatedText])
            documentPicker.allowsMultipleSelection = false
            documentPicker.delegate = CustomContext.shared
            if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
               let rootVC = windowScene.windows.first?.rootViewController {
                rootVC.present(documentPicker, animated: true, completion: nil)
            }
        })
        if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
           let rootVC = windowScene.windows.first?.rootViewController {
            rootVC.present(alert, animated: true, completion: nil)
        }
        return
    }
    
    // Ensures that all skill names are consistently capitalized
    private func normalizeSkillNamesIfNeeded() {
        // Check if we've already normalized skill names this session
        let normalizedKey = "ActionTracker.skillsNormalizedThisSession"
        if UserDefaults.standard.bool(forKey: normalizedKey) {
            return  // Already normalized this session
        }
        
        // Fetch all skills
        let skillsDescriptor = FetchDescriptor<Skill>()
        
        do {
            let allSkills = try context.fetch(skillsDescriptor)
            var changesMade = false
            
            // Normalize each skill name
            for skill in allSkills {
                let currentName = skill.name
                let normalizedName = Skill.normalizeSkillName(currentName)
                
                // Check if the name needs normalization
                if currentName != normalizedName {
                    print("Normalizing skill name from '\(currentName)' to '\(normalizedName)'")
                    skill.name = normalizedName
                    changesMade = true
                }
            }
            
            // Save changes if needed
            if changesMade {
                try context.save()
                print("Successfully normalized skill names")
            }
            
            // Mark as normalized for this session
            UserDefaults.standard.set(true, forKey: normalizedKey)
        } catch {
            print("Error normalizing skill names: \(error)")
        }
    }
    
    // MARK: - Data Wiping Functions
    private func resetActions() {
        // Get current experience for the summary
        let currentExperience = UserDefaults.standard.integer(forKey: "playerExperience")
        _ = UserDefaults.standard.integer(forKey: "totalExperienceGained")
        
        // Show confirmation alert with experience info
        let alert = UIAlertController(
            title: "Reset All Actions",
            message: "This will reset ALL to the default 3 starting actions, reset your experience to 0, and stop the timer if running. Your current experience is \(currentExperience). This action cannot be undone.",
            preferredStyle: .alert
        )
        
        alert.addAction(UIAlertAction(title: "Cancel", style: .cancel))
        alert.addAction(UIAlertAction(title: "Reset All", style: .destructive) { _ in
            self.executeResetActions()
        })
        
        // Present the alert
        if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
           let rootVC = windowScene.windows.first?.rootViewController {
            rootVC.present(alert, animated: true)
        }
    }
    
    private func executeResetActions() {
        print("DEBUG HeaderView: Executing reset actions")
        
        // First update mission notes if there's a timer running
        if timerRunningBinding {
            print("DEBUG HeaderView: Timer is running, updating mission notes before reset")
            updateMissionNotes()
            stopTimer()
        } else if timerStartDate != nil {
            print("DEBUG HeaderView: Timer was started but not running, updating mission notes")
            updateMissionNotes()
        }
        
        // Reset the actions
        withAnimation(.easeOut(duration: 0.5)) {
            actionItems = ActionItem.defaultActions()
        }
        
        // Reset experience to 0
        appViewModel.resetExperience()
        
        // Post a notification to tell ActionView to update its experience value
        NotificationCenter.default.post(name: NSNotification.Name("ResetExperience"), object: nil)
        
        print("DEBUG HeaderView: Experience and actions reset completed")
        
        // Don't show any summary dialog
    }
    
    private func wipeAllCharacters() {
        // Show confirmation alert
        let alert = UIAlertController(
            title: "Delete All Characters",
            message: "This will delete ALL characters in the database. Skills will remain but will be orphaned. This action cannot be undone.",
            preferredStyle: .alert
        )
        
        alert.addAction(UIAlertAction(title: "Cancel", style: .cancel))
        alert.addAction(UIAlertAction(title: "Delete All", style: .destructive) { _ in
            self.executeWipeAllCharacters()
        })
        
        // Present the alert
        if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
           let rootVC = windowScene.windows.first?.rootViewController {
            rootVC.present(alert, animated: true)
        }
    }
    
    private func executeWipeAllCharacters() {
        do {
            // 1. Fetch all characters
            let allCharacters = try context.fetch(FetchDescriptor<Character>())
            
            // 2. Delete all characters
            for character in allCharacters {
                context.delete(character)
            }
            
            // 3. Save changes
            try context.save()
            
            // 4. Post notification to refresh views
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                NotificationCenter.default.post(name: NSNotification.Name("RefreshCharacterData"), object: nil)
            }
        } catch {
            print("Error wiping characters: \(error)")
            
            // Show error alert
            let alert = UIAlertController(
                title: "Error",
                message: "Failed to delete characters: \(error.localizedDescription)",
                preferredStyle: .alert
            )
            alert.addAction(UIAlertAction(title: "OK", style: .default))
            
            if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
               let rootVC = windowScene.windows.first?.rootViewController {
                rootVC.present(alert, animated: true)
            }
        }
    }
    
    private func wipeAllCampaigns() {
        // Show confirmation alert
        let alert = UIAlertController(
            title: "Wipe All Campaigns",
            message: "This will delete ALL campaigns in the database. This action cannot be undone.",
            preferredStyle: .alert
        )
        
        alert.addAction(UIAlertAction(title: "Cancel", style: .cancel))
        alert.addAction(UIAlertAction(title: "Delete All", style: .destructive) { _ in
            self.executeWipeAllCampaigns()
        })
        
        // Present the alert
        if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
           let rootVC = windowScene.windows.first?.rootViewController {
            rootVC.present(alert, animated: true)
        }
    }
    
    private func executeWipeAllCampaigns() {
        do {
            let allCampaigns = try context.fetch(FetchDescriptor<Campaign>())
            
            for campaign in allCampaigns {
                context.delete(campaign)
            }
            
            try context.save()
            
            // Post notification to refresh views
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                NotificationCenter.default.post(name: NSNotification.Name("RefreshCharacterData"), object: nil)
            }
        } catch {
            print("Error wiping campaigns: \(error)")
            
            let alert = UIAlertController(
                title: "Error",
                message: "Failed to delete campaigns: \(error.localizedDescription)",
                preferredStyle: .alert
            )
            alert.addAction(UIAlertAction(title: "OK", style: .default))
            
            if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
               let rootVC = windowScene.windows.first?.rootViewController {
                rootVC.present(alert, animated: true)
            }
        }
    }
    
    private func wipeAllSkills() {
        // Show confirmation alert
        let alert = UIAlertController(
            title: "Delete All Skills",
            message: "This will delete ALL skills in the database and remove them from all characters. This action cannot be undone.",
            preferredStyle: .alert
        )
        
        alert.addAction(UIAlertAction(title: "Cancel", style: .cancel))
        alert.addAction(UIAlertAction(title: "Delete All", style: .destructive) { _ in
            self.executeWipeAllSkills()
        })
        
        // Present the alert
        if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
           let rootVC = windowScene.windows.first?.rootViewController {
            rootVC.present(alert, animated: true)
        }
    }
    
    private func executeWipeAllSkills() {
        do {
            // 1. First, clear skills from all characters
            for character in characters {
                character.skills = []
            }
            
            // 2. Fetch all skills
            let allSkills = try context.fetch(FetchDescriptor<Skill>())
            
            // 3. Delete all skills
            for skill in allSkills {
                context.delete(skill)
            }
            
            // 4. Save changes
            try context.save()
            
            // 5. Post notification to refresh views
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                NotificationCenter.default.post(name: NSNotification.Name("RefreshCharacterData"), object: nil)
            }
        } catch {
            print("Error wiping skills: \(error)")
            
            // Show error alert
            let alert = UIAlertController(
                title: "Error",
                message: "Failed to delete skills: \(error.localizedDescription)",
                preferredStyle: .alert
            )
            alert.addAction(UIAlertAction(title: "OK", style: .default))
            
            if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
               let rootVC = windowScene.windows.first?.rootViewController {
                rootVC.present(alert, animated: true)
            }
        }
    }
    
    private func wipeAllData() {
        // Show confirmation alert
        let alert = UIAlertController(
            title: "Delete ALL Data",
            message: "This will delete ALL characters AND skills in the database. The database will be completely empty. This action cannot be undone.",
            preferredStyle: .alert
        )
        
        alert.addAction(UIAlertAction(title: "Cancel", style: .cancel))
        alert.addAction(UIAlertAction(title: "Delete Everything", style: .destructive) { _ in
            self.executeWipeAllData()
        })
        
        // Present the alert
        if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
           let rootVC = windowScene.windows.first?.rootViewController {
            rootVC.present(alert, animated: true)
        }
    }
    
    private func executeWipeAllData() {
        do {
            // 1. First, delete all characters
            let allCharacters = try context.fetch(FetchDescriptor<Character>())
            for character in allCharacters {
                context.delete(character)
            }
            
            // 2. Then, delete all skills
            let allSkills = try context.fetch(FetchDescriptor<Skill>())
            for skill in allSkills {
                context.delete(skill)
            }
            
            // 3. Save changes
            try context.save()
            
            // 4. Post notification to refresh views
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                NotificationCenter.default.post(name: NSNotification.Name("RefreshCharacterData"), object: nil)
            }
        } catch {
            print("Error wiping all data: \(error)")
            
            // Show error alert
            let alert = UIAlertController(
                title: "Error",
                message: "Failed to delete all data: \(error.localizedDescription)",
                preferredStyle: .alert
            )
            alert.addAction(UIAlertAction(title: "OK", style: .default))
            
            if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
               let rootVC = windowScene.windows.first?.rootViewController {
                rootVC.present(alert, animated: true)
            }
        }
    }
}

#Preview {
    struct PreviewWrapper: View {
        @State private var timerRunning: Bool = false
        
        var body: some View {
            ContentView()
                .environmentObject(AppViewModel())
        }
    }
    
    return PreviewWrapper()
}


----- FILE: /Users/steve/Library/Mobile Documents/com~apple~CloudDocs/AppProjects/ActionTracker/ActionTracker/ViewExt.swift -----
//
//  ViewExt.swift
//  ActionTracker
//
//  Created by Stephen Parker on 4/2/25.
//

import Foundation
import SwiftUI

extension View {
    func disabledWithOpacity(_ status: Bool) -> some View {
        self
            .disabled(status)
            .opacity(status ? 0.5 : 1)
    }
}


----- FILE: /Users/steve/Library/Mobile Documents/com~apple~CloudDocs/AppProjects/ActionTracker/ActionTracker/SkillColorExtension.swift -----
//
//  SkillColorExtension.swift
//  ActionTracker
//
//  Created by Stephen Parker on 4/27/25.
//

import SwiftUI

extension Color {
    // Skill colors as constants
    static let skillBlue = Color(red: 0.0, green: 0.5, blue: 1.0)
    static let skillOrange = Color(red: 1.0, green: 0.6, blue: 0.0)
    static let skillRed = Color(red: 1.0, green: 0.2, blue: 0.2)
    
    // Get color from SkillColor enum
    static func forSkill(_ color: SkillColor) -> Color {
        switch color {
        case .blue:
            return skillBlue
        case .orange:
            return skillOrange
        case .red:
            return skillRed
        }
    }
    
    // Convenience method using optional SkillColor
    static func skillColor(_ color: SkillColor?) -> Color {
        guard let color = color else { return .gray }
        return forSkill(color)
    }
}

----- FILE: /Users/steve/Library/Mobile Documents/com~apple~CloudDocs/AppProjects/ActionTracker/ActionTracker/CampaignView.swift -----
//
//  CampaignView.swift
//  ActionTracker
//
//  Created by Stephen Parker on 4/22/25.
//

import SwiftUI
import SwiftData
import Foundation

struct CampaignView: View {
    @Environment(\.modelContext) private var context
    @Query private var campaigns: [Campaign]
    @State private var showingAddCampaign = false

    var body: some View {
        NavigationStack {
            List {
                ForEach(campaigns) { campaign in
                    NavigationLink(destination: CampaignDetailView(campaign: campaign)) {
                        CampaignRow(campaign: campaign)
                    }
                }
                .onDelete(perform: deleteCampaigns)
            }
            .toolbar {
                ToolbarItem(placement: .primaryAction) {
                    Button(action: { showingAddCampaign = true }) {
                        Image(systemName: "plus")
                    }
                }
                
                ToolbarItem(placement: .navigationBarLeading) {
                    EditButton()
                }
            }
            .sheet(isPresented: $showingAddCampaign) {
                AddCampaignView()
            }
        }
    }
    
    private func deleteCampaigns(at offsets: IndexSet) {
        for index in offsets {
            let campaign = campaigns[index]
            context.delete(campaign)
        }
        try? context.save()
    }
}

struct CampaignRow: View {
    var campaign: Campaign
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            HStack {
                Text(campaign.campaignName)
                    .font(.headline)
                Spacer()
                Text(formatDate(campaign.startDate))
                    .font(.caption)
                    .foregroundStyle(.secondary)
            }
            Text("Survivor: \(campaign.survivorName)")
                .font(.subheadline)
                .foregroundStyle(.secondary)
            Text("Total CXP: \(campaign.totalCXP)")
                .font(.caption)
                .foregroundStyle(.secondary)
        }
        .padding(.vertical, 4)
    }
    
    private func formatDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateStyle = .short
        formatter.timeStyle = .short
        return formatter.string(from: date)
    }
}

// MARK: Campaign Detail View
// Campaign detail view to show detailed progress
struct CampaignDetailView: View {
    @Bindable var campaign: Campaign
    @Environment(\.modelContext) private var context
    @State private var showingAddSkill = false
    @State private var showingAddAchievement = false
    @State private var showingAddEquipment = false
    @State private var showingAddMission = false
    @State private var newSkill = ""
    @State private var newAchievement = ""
    @State private var newEquipment = ""
    @FocusState private var focusedField: CampaignDetailField?
    
    enum CampaignDetailField: Hashable {
        case survivorName
        case achievement
        case equipment
    }
    
    private func deleteMission(_ mission: Mission) {
        // Adjust campaign values before deleting
        
        // Subtract CXP
        campaign.totalCXP -= mission.cxpEarned
        
        // Remove the earned bonus actions from the campaign
        campaign.bonusActionsEarned -= mission.bonusActionsUsed
        campaign.bonusActions -= mission.bonusActionsUsed
        
        // Remove the mission from the campaign
        campaign.missions?.removeAll { $0.id == mission.id }
        
        // Delete the mission from the context
        context.delete(mission)
        try? context.save()
    }
    
    private func insertTextAtCursor(_ text: String) {
        if let field = focusedField {
            switch field {
            case .survivorName:
                campaign.survivorName += text
            case .achievement:
                newAchievement += text
            case .equipment:
                newEquipment += text
            }
        }
    }
    
    var body: some View {
        List {
            Section("Survivor Info") {
                TextField("Survivor Name", text: $campaign.survivorName)
                    .focused($focusedField, equals: .survivorName)
                    .submitLabel(.done)
                    .onSubmit {
                        focusedField = nil
                    }
                
                HStack {
                    Text("Total CXP:")
                    Spacer()
                    
                    Text("\(campaign.totalCXP)")
                        .frame(minWidth: 40)
                }
            }

            Section("Campaign Skills") {
                if campaign.campaignSkills.isEmpty {
                    Text("No campaign skills yet.")
                        .foregroundStyle(.secondary)
                } else {
                    ForEach(campaign.campaignSkills, id: \.self) { skill in
                        Text(skill)
                    }
                }
            }

            Section("Bonus Actions") {
                HStack {
                    Text("Available:")
                    Spacer()
                    
                    Button("-", action: { 
                        if campaign.bonusActions > 0 {
                            campaign.bonusActions -= 1
                        }
                    })
                    .buttonStyle(.bordered)
                    .disabled(campaign.bonusActions <= 0)
                    
                    Text("\(campaign.bonusActions)")
                        .frame(minWidth: 40)
                    
                    Button("+", action: { 
                        // Only allow incrementing up to total earned
                        if campaign.bonusActions < campaign.bonusActionsEarned {
                            campaign.bonusActions += 1
                        }
                    })
                    .buttonStyle(.bordered)
                    .disabled(campaign.bonusActions >= campaign.bonusActionsEarned)
                }
                
                Text("Total Earned: \(campaign.bonusActionsEarned)")
                    .font(.caption)
                    .foregroundStyle(.secondary)
            }

            Section {
                HStack {
                    Text("Achievements")
                    Spacer()
                    Button(action: { 
                        showingAddAchievement = true 
                        focusedField = .achievement
                    }) {
                        Image(systemName: "plus.circle")
                    }
                }
                
                if showingAddAchievement {
                    HStack {
                        TextField("New Achievement", text: $newAchievement)
                            .focused($focusedField, equals: .achievement)
                            .submitLabel(.done)
                            .onSubmit {
                                if !newAchievement.isEmpty {
                                    campaign.campaignAchievements.append(newAchievement)
                                    newAchievement = ""
                                    showingAddAchievement = false
                                }
                            }
                        
                        Button("Add") {
                            if !newAchievement.isEmpty {
                                campaign.campaignAchievements.append(newAchievement)
                                newAchievement = ""
                                showingAddAchievement = false
                            }
                        }
                    }
                }
                
                if campaign.campaignAchievements.isEmpty && !showingAddAchievement {
                    Text("No achievements yet.")
                        .foregroundStyle(.secondary)
                } else {
                    ForEach(campaign.campaignAchievements, id: \.self) { achievement in
                        Text(achievement)
                    }
                    .onDelete { indexSet in
                        campaign.campaignAchievements.remove(atOffsets: indexSet)
                    }
                }
            }

            Section {
                HStack {
                    Text("Equipment Kept")
                    Spacer()
                    Button(action: { 
                        showingAddEquipment = true
                        focusedField = .equipment
                    }) {
                        Image(systemName: "plus.circle")
                    }
                }
                
                if showingAddEquipment {
                    HStack {
                        TextField("New Equipment", text: $newEquipment)
                            .focused($focusedField, equals: .equipment)
                            .submitLabel(.done)
                            .onSubmit {
                                if !newEquipment.isEmpty {
                                    campaign.equipmentKept.append(newEquipment)
                                    newEquipment = ""
                                    showingAddEquipment = false
                                }
                            }
                        
                        Button("Add") {
                            if !newEquipment.isEmpty {
                                campaign.equipmentKept.append(newEquipment)
                                newEquipment = ""
                                showingAddEquipment = false
                            }
                        }
                    }
                }
                
                if campaign.equipmentKept.isEmpty && !showingAddEquipment {
                    Text("No equipment saved yet.")
                        .foregroundStyle(.secondary)
                } else {
                    ForEach(campaign.equipmentKept, id: \.self) { equipment in
                        Text(equipment)
                    }
                    .onDelete { indexSet in
                        campaign.equipmentKept.remove(atOffsets: indexSet)
                    }
                }
            }

            Section {
                HStack {
                    Text("Missions")
                    Spacer()
                    Button(action: { showingAddMission = true }) {
                        Image(systemName: "plus.circle")
                    }
                }
                
                if campaign.missions?.isEmpty ?? true {
                    Text("No missions played yet.")
                        .foregroundStyle(.secondary)
                } else {
                    ForEach(campaign.missions ?? []) { mission in
                        NavigationLink(destination: MissionDetailView(mission: mission)) {
                            VStack(alignment: .leading, spacing: 4) {
                                Text(mission.missionName)
                                    .font(.headline)
                                Text("CXP Earned: \(mission.cxpEarned)")
                                    .font(.caption)
                                    .foregroundStyle(.secondary)
                                if !mission.equipmentGained.isEmpty {
                                    Text("Equipment: \(mission.equipmentGained.joined(separator: ", "))")
                                        .font(.caption2)
                                        .foregroundStyle(.secondary)
                                }
                            }
                            .padding(.vertical, 4)
                        }
                        .contextMenu {
                            Button(role: .destructive) {
                                deleteMission(mission)
                            } label: {
                                Label("Delete", systemImage: "trash")
                            }
                        }
                    }
                    .onDelete { indexSet in
                        if let missions = campaign.missions {
                            indexSet.forEach { index in
                                if index < missions.count {
                                    let mission = missions[index]
                                    deleteMission(mission)
                                }
                            }
                        }
                    }
                }
            }
        }
        .navigationTitle(campaign.campaignName)
        .navigationBarTitleDisplayMode(.inline)
        .toolbar {
            EditButton()
        }
        .sheet(isPresented: $showingAddMission) {
            AddMissionView(campaign: campaign)
        }
        .keyboardToolbar(
            onInsertText: { insertTextAtCursor($0) },
            onDone: { focusedField = nil }
        )
    }
}

// MARK: Add Campaign View
struct AddCampaignView: View {
    @Environment(\.modelContext) private var context
    @Environment(\.dismiss) private var dismiss
    
    @State private var campaignName = ""
    @State private var campaignDescription = ""
    @State private var selectedCharacter: Character?
    @State private var showingCharacterSelector = false
    @FocusState private var focusedField: CampaignField?
    
    enum CampaignField: Hashable {
        case name
        case description
    }
    
    var body: some View {
        NavigationStack {
            Form {
                Section("Campaign Information") {
                    TextField("Campaign Name", text: $campaignName)
                        .focused($focusedField, equals: .name)
                        .submitLabel(.next)
                        .onSubmit {
                            focusedField = .description
                        }
                    TextField("Description (Optional)", text: $campaignDescription)
                        .focused($focusedField, equals: .description)
                        .submitLabel(.done)
                        .onSubmit {
                            focusedField = nil
                        }
                }
                
                Section("Survivor Information") {
                    Button(action: {
                        showingCharacterSelector = true
                    }) {
                        HStack {
                            Text(selectedCharacter == nil ? "Select Character" : "Selected: \(selectedCharacter!.name)")
                            Spacer()
                            Image(systemName: "chevron.right")
                                .foregroundColor(.secondary)
                        }
                    }
                    
                    if let character = selectedCharacter {
                        VStack(alignment: .leading) {
                            Text(character.set?.isEmpty == false ? "Set: \(character.set!)" : "")
                                .font(.caption)
                                .foregroundColor(.secondary)
                            
                            // Display skills
                            if let skills = character.skills, !skills.isEmpty {
                                Text("Skills: \(skills.map { $0.name }.joined(separator: ", "))")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                        }
                    }
                }
            }
            .navigationTitle("New Campaign")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
                
                ToolbarItem(placement: .confirmationAction) {
                    Button("Save") {
                        addCampaign()
                    }
                    .disabled(campaignName.isEmpty || selectedCharacter == nil)
                }
            }
            .sheet(isPresented: $showingCharacterSelector) {
                CharacterSelectorView(selectedCharacter: $selectedCharacter, dismiss: { showingCharacterSelector = false })
            }
            .keyboardToolbar(
                onInsertText: { insertTextAtCursor($0) },
                onDone: { focusedField = nil }
            )
        }
    }
    
    private func insertTextAtCursor(_ text: String) {
        if let field = focusedField {
            switch field {
                case .name:
                    campaignName.append(text)
                case .description:
                    campaignDescription.append(text)
            }
        }
    }
    
    private func addCampaign() {
        guard let character = selectedCharacter else { return }
        
        let newCampaign = Campaign(
            campaignName: campaignName,
            survivorName: character.name,
            campaignDescription: campaignDescription.isEmpty ? nil : campaignDescription
        )
        
        context.insert(newCampaign)
        try? context.save()
        dismiss()
    }
}

// MARK: Add Mission View
struct AddMissionView: View {
    @Environment(\.dismiss) private var dismiss
    @Environment(\.modelContext) private var context
    @EnvironmentObject private var appViewModel: AppViewModel
    
    var campaign: Campaign
    
    @State private var missionName = ""
    @State private var cxpEarned = 0
    @State private var bonusActionsUsed = 0
    @State private var newEquipment = ""
    @State private var equipmentList: [String] = []
    @State private var newObjective = ""
    @State private var objectivesList: [String] = []
    @State private var notes = ""
    @State private var missionSaved = false
    @FocusState private var focusedField: MissionField?
    
    enum MissionField: Hashable {
        case name, equipment, objective, notes
    }
    
    var body: some View {
        NavigationStack {
            Form {
                Section("Mission Information") {
                    TextField("Mission Name", text: $missionName)
                        .focused($focusedField, equals: .name)
                        .submitLabel(.next)
                        .onSubmit {
                            focusedField = .notes
                        }
                    
                    Stepper("CXP Earned: \(cxpEarned)", value: $cxpEarned, in: 0...100)
                    Stepper("Bonus Actions Earned: \(bonusActionsUsed)", value: $bonusActionsUsed, in: 0...10)
                    
                    TextField("Notes (Optional)", text: $notes, axis: .vertical)
                        .focused($focusedField, equals: .notes)
                        .submitLabel(.done)
                        .onSubmit {
                            focusedField = nil
                        }
                        .lineLimit(3, reservesSpace: true)
                }
                
                Section("Equipment Gained") {
                    HStack {
                        TextField("Add Equipment", text: $newEquipment)
                            .focused($focusedField, equals: .equipment)
                            .submitLabel(.done)
                            .onSubmit {
                                addEquipment()
                            }
                        
                        Button("Add") {
                            addEquipment()
                        }
                        .disabled(newEquipment.isEmpty)
                    }
                    
                    ForEach(equipmentList, id: \.self) { item in
                        Text(item)
                    }
                    .onDelete { indexSet in
                        equipmentList.remove(atOffsets: indexSet)
                    }
                }
                
                Section("Objectives Completed") {
                    HStack {
                        TextField("Add Objective", text: $newObjective)
                            .focused($focusedField, equals: .objective)
                            .submitLabel(.done)
                            .onSubmit {
                                addObjective()
                            }
                        
                        Button("Add") {
                            addObjective()
                        }
                        .disabled(newObjective.isEmpty)
                    }
                    
                    ForEach(objectivesList, id: \.self) { item in
                        Text(item)
                    }
                    .onDelete { indexSet in
                        objectivesList.remove(atOffsets: indexSet)
                    }
                }
            }
            .navigationTitle("Add Mission")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
                
                ToolbarItem(placement: .confirmationAction) {
                    Button("Save") {
                        saveMission()
                        missionSaved = true
                    }
                    .disabled(missionName.isEmpty)
                }
            }
            .keyboardToolbar(
                onInsertText: { insertTextAtCursor($0) }, 
                onDone: { focusedField = nil }
            )
            .alert("Start New Mission", isPresented: $missionSaved) {
                Button("Yes, Start Timer") {
                    // Start the timer by posting a notification
                    NotificationCenter.default.post(name: NSNotification.Name("StartNewMissionTimer"), object: nil)
                    
                    // Set the active view tab to action and navigate away
                    UserDefaults.standard.set("action", forKey: "activeViewTab")
                    dismiss()
                }
                Button("No, Just Prepare") {
                    // Set the active view tab to action and navigate away without starting timer
                    UserDefaults.standard.set("action", forKey: "activeViewTab")
                    dismiss()
                }
            } message: {
                Text("Do you want to start the timer for the new mission?")
            }
        }
    }
    
    private func insertTextAtCursor(_ text: String) {
        if let field = focusedField {
            switch field {
                case .name:
                    missionName += text
                case .equipment:
                    newEquipment += text
                case .objective:
                    newObjective += text
                case .notes:
                    notes += text
            }
        }
    }
    
    private func addEquipment() {
        if !newEquipment.isEmpty {
            equipmentList.append(newEquipment)
            newEquipment = ""
            focusedField = .equipment
        }
    }
    
    private func addObjective() {
        if !newObjective.isEmpty {
            objectivesList.append(newObjective)
            newObjective = ""
            focusedField = .objective
        }
    }
    
    private func resetMissionState() {
        // 1. Set the selected character to the campaign's character
        if let character = findCampaignCharacter() {
            appViewModel.selectCharacter(character)
        }
        
        // 2. Reset experience to 0
        appViewModel.resetExperience()
        
        // 3. Reset actions
        // This is handled through a notification that ActionView will listen to
        NotificationCenter.default.post(name: NSNotification.Name("ResetExperience"), object: nil)
    }
    
    private func findCampaignCharacter() -> Character? {
        // Try to find a character matching the survivor name and set
        let descriptor = FetchDescriptor<Character>()
        do {
            let characters = try context.fetch(descriptor)
            
            // First try to find an exact match with both name and set
            // Note: Campaign doesn't store the set, so we need to look for the character
            // that was most likely used when creating the campaign
            
            // Strategy 1: First look for exact name match with any character that has a set
            let exactNameWithSet = characters.filter { 
                $0.name == campaign.survivorName && $0.set != nil && !$0.set!.isEmpty 
            }
            
            if !exactNameWithSet.isEmpty {
                // If we found characters with the name and a set, use the first one
                // More precise matching would require storing the set in the campaign
                return exactNameWithSet.first
            }
            
            // Strategy 2: Find character with exact name and no set
            let exactNameNoSet = characters.filter {
                $0.name == campaign.survivorName && ($0.set == nil || $0.set!.isEmpty)
            }
            
            if !exactNameNoSet.isEmpty {
                return exactNameNoSet.first
            }
            
            // Strategy 3: Find any character with the name
            return characters.first { $0.name == campaign.survivorName }
        } catch {
            print("Error fetching characters: \(error)")
            return nil
        }
    }
    
    private func saveMission() {
        let mission = Mission(
            missionName: missionName,
            cxpEarned: cxpEarned,
            objectivesCompleted: objectivesList,
            bonusActionsUsed: bonusActionsUsed,
            equipmentGained: equipmentList,
            notes: notes.isEmpty ? nil : notes
        )
        
        campaign.missions?.append(mission)
        
        // Update campaign totals based on mission data
        campaign.totalCXP += cxpEarned
        
        // Add bonus actions earned to the campaign
        campaign.bonusActionsEarned += bonusActionsUsed
        campaign.bonusActions += bonusActionsUsed
        
        // Add any new equipment to kept equipment
        for equipment in equipmentList {
            if !campaign.equipmentKept.contains(equipment) {
                campaign.equipmentKept.append(equipment)
            }
        }
        
        try? context.save()
        
        // Start tracking the new mission
        if let missionID = mission.id.uuidString as String? {
            appViewModel.startTrackingMission(missionID: missionID)
        }
        
        // Reset the mission state before showing the alert
        resetMissionState()
    }
}

// MARK: Mission Detail View 
struct MissionDetailView: View {
    @Bindable var mission: Mission
    @Environment(\.modelContext) private var context
    @State private var showingAddEquipment = false
    @State private var showingAddObjective = false
    @State private var showingAddCampaignSkill = false
    @State private var newEquipment = ""
    @State private var newObjective = ""
    @State private var selectedCampaignSkill = ""
    @FocusState private var focusedField: MissionDetailField?
    
    enum MissionDetailField: Hashable {
        case name
        case notes
        case equipment
        case objective
    }
    
    // Available campaign skills
    private let availableCampaignSkills = [
        "Combat reflexes", 
        "Destiny", 
        "Hoard", 
        "Hold your nose", 
        "Home defender", 
        "Lifesaver", 
        "Low profile", 
        "Night fighter", 
        "Sidestep", 
        "Starts with 2 AP", 
        "Starts with a Repair Kit", 
        "Starts with an Ammo card", 
        "Steady hand", 
        "Webbing"
    ]
    
    private func insertTextAtCursor(_ text: String) {
        if let field = focusedField {
            switch field {
            case .name:
                mission.missionName += text
            case .notes:
                if mission.notes == nil {
                    mission.notes = text
                } else {
                    mission.notes! += text
                }
            case .equipment:
                newEquipment += text
            case .objective:
                newObjective += text
            }
        }
    }
    
    var body: some View {
        Form {
            Section {
                TextField("Mission Name", text: $mission.missionName)
                    .focused($focusedField, equals: .name)
                    .submitLabel(.next)
                    .onSubmit {
                        focusedField = .notes
                    }
                
                Stepper("CXP Earned: \(mission.cxpEarned)", value: $mission.cxpEarned, in: 0...100)
                    .onChange(of: mission.cxpEarned) { oldValue, newValue in
                        // Update campaign total whenever mission CXP changes
                        if let campaign = mission.campaign {
                            let difference = newValue - oldValue
                            campaign.totalCXP += difference
                        }
                    }
                
                // This is now "Bonus Actions Earned" but the field name remains the same
                Stepper("Bonus Actions Earned: \(mission.bonusActionsUsed)", value: $mission.bonusActionsUsed, in: 0...10)
                    .onChange(of: mission.bonusActionsUsed) { oldValue, newValue in
                        // Update campaign's bonus actions whenever mission's earned actions changes
                        if let campaign = mission.campaign {
                            let difference = newValue - oldValue
                            campaign.bonusActionsEarned += difference  // Update total earned
                            campaign.bonusActions += difference  // Update available
                        }
                    }
                
                if mission.notes != nil {
                    TextField("Notes", text: Binding(
                        get: { mission.notes ?? "" },
                        set: { mission.notes = $0.isEmpty ? nil : $0 }
                    ), axis: .vertical)
                    .focused($focusedField, equals: .notes)
                    .submitLabel(.done)
                    .lineLimit(3, reservesSpace: true)
                } else {
                    Button("Add Notes") {
                        mission.notes = ""
                        focusedField = .notes
                    }
                }
            }
            
            Section {
                HStack {
                    Text("Campaign Skills")
                    Spacer()
                    Button(action: {
                        showingAddCampaignSkill = true
                    }) {
                        Image(systemName: "plus.circle")
                    }
                }
                
                if showingAddCampaignSkill {
                    Picker("Select Campaign Skill", selection: $selectedCampaignSkill) {
                        Text("Select a skill").tag("")
                        ForEach(availableCampaignSkills.filter { skill in
                            guard let campaign = mission.campaign else { return true }
                            return !campaign.campaignSkills.contains(skill)
                        }, id: \.self) { skill in
                            Text(skill).tag(skill)
                        }
                    }
                    
                    Button("Add Skill") {
                        if !selectedCampaignSkill.isEmpty {
                            if let campaign = mission.campaign {
                                // Add to campaign skills
                                campaign.campaignSkills.append(selectedCampaignSkill)
                                selectedCampaignSkill = ""
                                showingAddCampaignSkill = false
                            }
                        }
                    }
                    .disabled(selectedCampaignSkill.isEmpty)
                }
                
                if let campaign = mission.campaign, !campaign.campaignSkills.isEmpty {
                    ForEach(campaign.campaignSkills, id: \.self) { skill in
                        Text(skill)
                    }
                    .onDelete { indexSet in
                        if let campaign = mission.campaign {
                            campaign.campaignSkills.remove(atOffsets: indexSet)
                        }
                    }
                } else if !showingAddCampaignSkill {
                    Text("No campaign skills yet.")
                        .foregroundStyle(.secondary)
                }
            }
            
            Section {
                HStack {
                    Text("Equipment Gained")
                    Spacer()
                    Button(action: {
                        showingAddEquipment = true
                        focusedField = .equipment
                    }) {
                        Image(systemName: "plus.circle")
                    }
                }
                
                if showingAddEquipment {
                    HStack {
                        TextField("New Equipment", text: $newEquipment)
                            .focused($focusedField, equals: .equipment)
                            .submitLabel(.done)
                            .onSubmit {
                                if !newEquipment.isEmpty {
                                    mission.equipmentGained.append(newEquipment)
                                    // Also add to campaign's kept equipment
                                    if let campaign = mission.campaign, !campaign.equipmentKept.contains(newEquipment) {
                                        campaign.equipmentKept.append(newEquipment)
                                    }
                                    newEquipment = ""
                                    showingAddEquipment = false
                                }
                            }
                        
                        Button("Add") {
                            if !newEquipment.isEmpty {
                                mission.equipmentGained.append(newEquipment)
                                // Also add to campaign's kept equipment
                                if let campaign = mission.campaign, !campaign.equipmentKept.contains(newEquipment) {
                                    campaign.equipmentKept.append(newEquipment)
                                }
                                newEquipment = ""
                                showingAddEquipment = false
                            }
                        }
                    }
                }
                
                if mission.equipmentGained.isEmpty && !showingAddEquipment {
                    Text("No equipment gained.")
                        .foregroundStyle(.secondary)
                } else {
                    ForEach(mission.equipmentGained, id: \.self) { equipment in
                        Text(equipment)
                    }
                    .onDelete { indexSet in
                        mission.equipmentGained.remove(atOffsets: indexSet)
                    }
                }
            }
            
            Section {
                HStack {
                    Text("Objectives Completed")
                    Spacer()
                    Button(action: {
                        showingAddObjective = true
                        focusedField = .objective
                    }) {
                        Image(systemName: "plus.circle")
                    }
                }
                
                if showingAddObjective {
                    HStack {
                        TextField("New Objective", text: $newObjective)
                            .focused($focusedField, equals: .objective)
                            .submitLabel(.done)
                            .onSubmit {
                                if !newObjective.isEmpty {
                                    mission.objectivesCompleted.append(newObjective)
                                    newObjective = ""
                                    showingAddObjective = false
                                }
                            }
                        
                        Button("Add") {
                            if !newObjective.isEmpty {
                                mission.objectivesCompleted.append(newObjective)
                                newObjective = ""
                                showingAddObjective = false
                            }
                        }
                    }
                }
                
                if mission.objectivesCompleted.isEmpty && !showingAddObjective {
                    Text("No objectives completed.")
                        .foregroundStyle(.secondary)
                } else {
                    ForEach(mission.objectivesCompleted, id: \.self) { objective in
                        Text(objective)
                    }
                    .onDelete { indexSet in
                        mission.objectivesCompleted.remove(atOffsets: indexSet)
                    }
                }
            }
        }
        .navigationTitle(mission.missionName)
        .navigationBarTitleDisplayMode(.inline)
        .keyboardToolbar(
            onInsertText: { insertTextAtCursor($0) },
            onDone: { focusedField = nil }
        )
    }
}

// Character Selector View
struct CharacterSelectorView: View {
    @Binding var selectedCharacter: Character?
    var dismiss: () -> Void
    
    // Use a custom query that will let us sort by favorite status
    @Query private var characters: [Character]
    @State private var searchText = ""
    
    // Initialize with a custom query
    init(selectedCharacter: Binding<Character?>, dismiss: @escaping () -> Void) {
        self._selectedCharacter = selectedCharacter
        self.dismiss = dismiss
        
        // Initialize query with default sorting 
        // (We'll handle favorite sorting in the computed property)
        let descriptor = FetchDescriptor<Character>(sortBy: [SortDescriptor(\.name)])
        self._characters = Query(descriptor)
    }
    
    // Sorted characters with favorites first
    var sortedCharacters: [Character] {
        return characters.sorted { char1, char2 in
            // First check favorite status (favorites come first)
            if char1.isFavorite && !char2.isFavorite {
                return true
            } else if !char1.isFavorite && char2.isFavorite {
                return false
            }
            
            // If both have the same favorite status, sort by name
            return char1.name.localizedCaseInsensitiveCompare(char2.name) == .orderedAscending
        }
    }
    
    var filteredCharacters: [Character] {
        guard !searchText.isEmpty else { return sortedCharacters }
        
        // Check for special search tokens
        if searchText.lowercased().hasPrefix("set:") {
            let setQuery = searchText.dropFirst(4).trimmingCharacters(in: .whitespaces)
            return sortedCharacters.filter { 
                guard let set = $0.set else { return false }
                return set.localizedCaseInsensitiveContains(setQuery)
            }
        } else if searchText.lowercased().hasPrefix("skill:") {
            let skillQuery = searchText.dropFirst(6).trimmingCharacters(in: .whitespaces)
            return sortedCharacters.filter { char in
                // unwrap or default to empty
                let skills = char.skills ?? []
                return skills.contains {
                    $0.name.localizedCaseInsensitiveContains(skillQuery)
                }
            }
        } else {
            // Standard search - name or any skill
            return sortedCharacters.filter { char in
                let skills = char.skills ?? []
                return
                    char.name.localizedCaseInsensitiveContains(searchText) ||
                    skills.contains { $0.name.localizedCaseInsensitiveContains(searchText) } ||
                    (char.set ?? "").localizedCaseInsensitiveContains(searchText)
            }
        }
    }
    
    var body: some View {
        NavigationStack {
            VStack(spacing: 0) {
                // Search bar at the top
                CharacterListView.SearchBar(text: $searchText)
                    .padding(.horizontal)
                    .padding(.vertical, 8)
                    .background(Color(.systemBackground))
                
                List {
                    ForEach(filteredCharacters) { character in
                        Button {
                            selectedCharacter = character
                            dismiss()
                        } label: {
                            HStack(alignment: .top) {
                                VStack(alignment: .leading) {
                                    HStack {
                                        // Show star icon for favorites
                                        if character.isFavorite {
                                            Image(systemName: "star.fill")
                                                .foregroundColor(.yellow)
                                                .font(.caption)
                                        }
                                    
                                        Text(character.set?.isEmpty == false ? "\(character.name) (\(character.set!))" : character.name)
                                            .font(.headline)
                                    }
                                    
                                    // Display skills sorted by position
                                    if !(character.skills ?? []).isEmpty {
                                        SkillsWithDescriptionView(skills: (character.skills ?? []).sorted { $0.position < $1.position })
                                    }
                                }
                                
                                Spacer()
                                
                                // Add a checkmark for the currently selected character
                                if let selectedChar = selectedCharacter, selectedChar.id == character.id {
                                    Image(systemName: "checkmark")
                                        .foregroundColor(.blue)
                                }
                            }
                            .foregroundColor(.primary)
                        }
                    }
                }
                .searchSuggestions {
                    if searchText.isEmpty {
                        Text("Try searching by name")
                            .searchCompletion("Fred")
                        Text("Search by set")
                            .searchCompletion("set: Core")
                        Text("Filter by skill")
                            .searchCompletion("skill: +1 Die")
                    }
                }
                .listStyle(PlainListStyle())
            }
            .navigationTitle("Select Character")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
            }
        }
    }
}



----- FILE: /Users/steve/Library/Mobile Documents/com~apple~CloudDocs/AppProjects/ActionTracker/ActionTracker/ActionTrackerApp.swift -----
//
//  ActionTrackerApp.swift
//  ActionTracker
//
//  Created by Stephen Parker on 4/1/25.
//

import SwiftUI
import SwiftData
import OSLog

// We'll use the standard modelContainer modifier instead of a shared container

@main
struct ActionTrackerApp: App {
    // Setup logger
    private let logger = Logger(subsystem: "com.parker1978.ActionTracker", category: "SwiftData")
    
    // Create a simplified SwiftData container
    @State private var modelContainerError: Error?
    
    // Main app state manager as a single source of truth
    @StateObject private var appViewModel = AppViewModel()
    
    var body: some Scene {
        WindowGroup {
            ContentView()
                .modelContainer(for: [Character.self, Skill.self, Campaign.self, Mission.self])
                .environmentObject(appViewModel)
                .onAppear {
                    // Reset the persistent store if there was an error with migrations
                    if UserDefaults.standard.bool(forKey: "swiftdata_reset_needed") {
                        resetSwiftDataStore()
                        UserDefaults.standard.set(false, forKey: "swiftdata_reset_needed")
                    }
                }
                .onReceive(NotificationCenter.default.publisher(for: .modelContainerError)) { notification in
                    if let error = notification.userInfo?["error"] as? Error {
                        logger.error("SwiftData error: \(error.localizedDescription)")
                        logger.error("Error details: \(String(describing: error))")
                        
                        // Set flag to reset store on next launch
                        UserDefaults.standard.set(true, forKey: "swiftdata_reset_needed")
                    }
                }
        }
    }
    
    // Helper function to reset the SwiftData store if needed
    private func resetSwiftDataStore() {
        logger.notice("Resetting SwiftData store due to previous error")
        
        // Get URL for the SwiftData store
        let storeURL = URL.applicationSupportDirectory
            .appending(path: "default.store")
        
        // Try to remove files
        do {
            if FileManager.default.fileExists(atPath: storeURL.path) {
                try FileManager.default.removeItem(at: storeURL)
                logger.notice("Successfully reset SwiftData store")
            }
        } catch {
            logger.error("Failed to reset SwiftData store: \(error.localizedDescription)")
        }
    }
}

// Extension for SwiftData error notifications
extension Notification.Name {
    static let modelContainerError = Notification.Name("modelContainerError")
}


----- FILE: /Users/steve/Library/Mobile Documents/com~apple~CloudDocs/AppProjects/ActionTracker/ActionTracker/AddCharacterView.swift -----
//
//  AddCharacterView.swift
//  ZombicideCharacters
//
//  Created by Stephen Parker on 4/11/25.
//

import SwiftUI
import SwiftData
import Foundation

struct AddCharacterView: View {
    @Environment(\.dismiss) private var dismiss
    @Environment(\.modelContext) private var context
    @Environment(\.editMode) private var editMode

    @State private var name: String = ""
    @State private var set: String = ""
    @State private var notes: String = ""
    @State private var isFavorite: Bool = false
    @State private var skillInputs: [(id: UUID, name: String, skillDescription: String, color: SkillColor, position: Int, showDescription: Bool)] = [(UUID(), "", "", .blue, 0, false)]
    @State private var showingValidationAlert = false
    @State private var errorMessage = ""
    @State private var isDragging = false
    @State private var editModeState: EditMode = .inactive
    @FocusState private var focusField: Field?
    
    var character: Character?
    
    enum Field: Hashable {
        case name
        case set
        case notes
        case skillName(Int)
        case skillDesc(Int)
    }
    
    var canSave: Bool {
        !name.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty && 
        !skillInputs.filter { !$0.name.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty }.isEmpty
    }
    
    var isEditing: Bool {
        character != nil
    }
    
    init(character: Character? = nil) {
        self.character = character
        
        if let character = character {
            _name = State(initialValue: character.name)
            _set = State(initialValue: character.set ?? "")
            _notes = State(initialValue: character.notes ?? "")
            _isFavorite = State(initialValue: character.isFavorite)
            
            // Get skills from the character, including duplicates, sorted by position
            if let skills = character.skills, !skills.isEmpty {
                // Convert skills to our tuple format
                let skillsData = skills.map { skill in
                    (
                        id: UUID(),                   // Unique ID for this skill input
                        name: skill.name,             // Skill name 
                        skillDescription: skill.skillDescription, // Description
                        color: skill.color ?? .blue,  // Default to blue if nil
                        position: skill.position,     // Preserve position
                        showDescription: false        // Start with descriptions hidden
                    )
                }.sorted { $0.position < $1.position } // Sort by position
                
                _skillInputs = State(initialValue: skillsData)
                
                // Print debug info
                print("CHARACTER INITIALIZATION")
                print("Found \(skills.count) skills for character \(character.name)")
                for skill in skillsData {
                    print("Loaded skill: \(skill.name) (Color: \(skill.color), Position: \(skill.position))")
                }
            } else {
                // Default empty skill if no skills found
                _skillInputs = State(initialValue: [(UUID(), "", "", .blue, 0, false)])
                print("No skills found for character \(character.name)")
            }
        } else {
            // Default single empty skill for new character
            _skillInputs = State(initialValue: [(UUID(), "", "", .blue, 0, false)])
            print("Creating new character with default empty skill")
        }
    }
    
    // Swift compiler requires this workaround for proper preview
    init() {
        self.character = nil
    }
    
    var body: some View {
        NavigationStack {
            VStack(spacing: 0) {
//                // DEBUG: show current editMode
//                Text("DEBUG editMode: \(String(describing: editMode?.wrappedValue))")
//                    .font(.caption2)
//                    .foregroundColor(.orange)
//                    .padding(.vertical, 4)
//                
                Form {
                    characterInfoSection
                    skillsSection
                }
                .navigationTitle(isEditing ? "Edit Character" : "Add Character")
                .navigationBarTitleDisplayMode(.inline)
                .keyboardToolbar(
                    onInsertText: { insertTextAtCursor($0) },
                    onDone: { focusField = nil }
                )
            }
            .toolbar {
                // Edit mode button in leading position
                ToolbarItem(placement: .navigationBarTrailing) {
                    EditButton()
                }
                
                cancelButton
                saveButton
            }
            .environment(\.editMode, $editModeState)
            .alert("Missing Information", isPresented: $showingValidationAlert) {
                Button("OK") {
                    if errorMessage.contains("name") {
                        focusField = .name
                    } else {
                        focusField = .skillName(0)
                    }
                }
            } message: {
                Text(errorMessage)
            }
            .onAppear {
                // Only set initial focus if we're adding a new character (not editing)
                if !isEditing {
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                        focusField = .name
                    }
                }
                
                // Make sure positions are normalized when view appears
                normalizePositions()
            }
            .onChange(of: editModeState) { old, new in
                print(" editMode changed from \(old) to \(new)")
                if new == .inactive {
                  withAnimation { normalizePositions() }
                }
              }
            // log every change to the console
            .onChange(of: editMode?.wrappedValue, initial: false) { oldMode, newMode in
                print(" editMode changed from \(String(describing: oldMode)) to \(String(describing: newMode))")
            }
        }
    }
    
    // MARK: - View Components
    
    private var characterInfoSection: some View {
        Section("Name") {
            TextField("Character Name", text: $name)
                .textInputAutocapitalization(.words)
                .focused($focusField, equals: .name)
                .submitLabel(.next)
                .onSubmit {
                    focusField = .set
                }
            
            TextField("Set (optional)", text: $set)
                .textInputAutocapitalization(.words)
                .focused($focusField, equals: .set)
                .submitLabel(.next)
                .onSubmit {
                    focusField = .notes
                }
            
            TextField("Notes (optional)", text: $notes)
                .textInputAutocapitalization(.never)
                .focused($focusField, equals: .notes)
                .submitLabel(.done)
                .onSubmit {
                    focusField = nil
                }
            
            Toggle(isOn: $isFavorite) {
                HStack {
                    Text("Favorite")
                    if isFavorite {
                        Image(systemName: "star.fill")
                            .foregroundColor(.yellow)
                    }
                }
            }
        }
    }
    
    private var isEditModeEditing: Bool {
      editMode?.wrappedValue.isEditing == true
    }
    
    // MARK: Skills Section
    private var skillsSection: some View {
        Section {
            // All skills in one list, sorted by position
            ForEach(skillInputs.sorted(by: { $0.position < $1.position }), id: \.id) { skill in
                let index = skillInputs.firstIndex { $0.id == skill.id } ?? 0
                skillRow(for: index)
                    .id("\(skill.id)-\(isEditModeEditing)") // Force redraw when edit mode changes
                    .swipeActions(edge: .trailing) {
                        Button(role: .destructive) {
                            withAnimation(.spring(duration: 0.3)) {
                                if index > 0 { // Prevent deleting the first skill
                                    removeSkill(at: index)
                                }
                            }
                        } label: {
                            Label("Delete", systemImage: "trash")
                        }
                    }
            }
            .onMove(perform: moveSkill)
            
            // Add skill button
            addSkillButton
        } header: {
            Text("Skills")
        }
    }
    
    // Helper to get color based on skill color enum
    private func colorForSkill(_ skill: (id: UUID, name: String, skillDescription: String, color: SkillColor, position: Int, showDescription: Bool)) -> Color {
        switch skill.color {
        case .blue:
            return .skillBlue
        case .orange:
            return .skillOrange
        case .red:
            return .skillRed
        }
    }
    
    // Helper to determine if we're in edit mode
    private var isEditModeActive: Bool {
        return editMode?.wrappedValue == .active
    }
    
    // MARK: Skill Row
    @ViewBuilder
    private func skillRow(for index: Int) -> some View {
        VStack(alignment: .leading, spacing: 8) {
            // Skill name field with dot indicator
            HStack {
                Circle()
                    .fill(colorForSkill(skillInputs[index]))
                    .frame(width: 8, height: 8)
                TextField("Skill Name", text: $skillInputs[index].name)
                    .textInputAutocapitalization(.words)
                    .focused($focusField, equals: .skillName(index))
                    .submitLabel(.done)
            }
            
            // ONLY include the picker while editing
            if editModeState == .active {
                Picker("Power Level", selection: $skillInputs[index].color) {
                    Text("Blue").tag(SkillColor.blue)
                    Text("Orange").tag(SkillColor.orange)
                    Text("Red").tag(SkillColor.red)
                }
                .pickerStyle(.segmented)
                .onChange(of: skillInputs[index].color) { _, newValue in
                    withAnimation { normalizePositionsByColor() }
                }
                .transition(.opacity)
                .animation(.easeInOut(duration: 0.1), value: editModeState)
            }
        }
        .padding(.vertical, 2)
        .animation(.spring(duration: 0.3), value: editMode?.wrappedValue)
    }
    
    private var addSkillButton: some View {
        Button {
            withAnimation {
                // Find the highest position value and add 1
                let nextPosition = (skillInputs.map { $0.position }.max() ?? -1) + 1
                
                // Add the new skill
                skillInputs.append((UUID(), "", "", .blue, nextPosition, false))
                
                // Ensure positions are normalized
                normalizePositionsByColor()
                
                // Focus the new field
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                    focusField = .skillName(skillInputs.count - 1)
                }
            }
        } label: {
            HStack {
                Image(systemName: "plus.circle")
                    .foregroundColor(.blue)
                Text("Add Skill")
                    .foregroundColor(.blue)
            }
        }
        .disabled(editMode?.wrappedValue == .active) // Disable adding skills while in edit mode
    }
    
    // Helper method to insert text at the cursor position
    private func insertTextAtCursor(_ text: String) {
        // Determine which field has focus and insert text there
        if let field = focusField {
            switch field {
            case .name:
                name.append(text)
            case .set:
                set.append(text)
            case .notes:
                notes.append(text)
            case .skillName(let index):
                if index < skillInputs.count {
                    skillInputs[index].name.append(text)
                }
            case .skillDesc(let index):
                if index < skillInputs.count {
                    skillInputs[index].skillDescription.append(text)
                }
            }
        }
    }
    
    private var cancelButton: some ToolbarContent {
        ToolbarItem(placement: .cancellationAction) {
            Button("Cancel") {
                dismiss()
            }
        }
    }
    
    private var saveButton: some ToolbarContent {
        ToolbarItem(placement: .confirmationAction) {
            Button("Save") {
                saveCharacter()
            }
            .disabled(!canSave)
        }
    }
    
    // MARK: - Helper Methods
    
    private func removeSkill(at index: Int) {
        if index < skillInputs.count {
            skillInputs.remove(at: index)
            normalizePositions()
        }
    }
    
    // Move skills within a color section
    private func moveSkillWithinSection(source: IndexSet, destination: Int, section: SkillColor) {
        // Get all skills of this color
        var skillsInSection = skillInputs.filter { $0.color == section }
        
        // Move the items within this filtered array
        skillsInSection.move(fromOffsets: source, toOffset: destination)
        
        // Update positions within this section
        for (index, skill) in skillsInSection.enumerated() {
            if let actualIndex = skillInputs.firstIndex(where: { $0.id == skill.id }) {
                // Find position based on the color
                var basePosition = 0
                
                if section == .orange {
                    basePosition = skillInputs.filter { $0.color == .blue }.count
                } else if section == .red {
                    basePosition = skillInputs.filter { $0.color == .blue }.count + 
                                  skillInputs.filter { $0.color == .orange }.count
                }
                
                // Set the new position
                withAnimation {
                    skillInputs[actualIndex].position = basePosition + index
                }
            }
        }
        
        // Normalize all positions to ensure consistency
        normalizePositionsByColor()
    }
    
    // Improved move skills function
    private func moveSkill(from source: IndexSet, to destination: Int) {
        // Get a sorted array of skills by position
        var sortedSkills = skillInputs.sorted(by: { $0.position < $1.position })
        
        // Move the items within this sorted array
        sortedSkills.move(fromOffsets: source, toOffset: destination)
        
        // Update all positions based on the new order
        for (newPosition, skill) in sortedSkills.enumerated() {
            if let index = skillInputs.firstIndex(where: { $0.id == skill.id }) {
                // Update position in the original array
                skillInputs[index].position = newPosition
                
                // Print for debugging
                print("Moved skill '\(skill.name)' to position \(newPosition)")
            }
        }
        
        // Force an immediate context save when in edit mode
        if editMode?.wrappedValue == .active {
            do {
                try context.save()
                print("Saved context after skill reordering")
            } catch {
                print("Failed to save context after reordering: \(error)")
            }
        }
    }
    
    // Simple position normalization (kept for compatibility)
    private func normalizePositions() {
        // Sort by current order in the array
        for i in 0..<skillInputs.count {
            skillInputs[i].position = i
        }
    }
    
    // Normalize positions by color group
    private func normalizePositionsByColor() {
        withAnimation(.spring(duration: 0.2)) {
            // Group skills by color
            let blueSkills = skillInputs.filter { $0.color == .blue }
                .sorted { $0.position < $1.position }
            let orangeSkills = skillInputs.filter { $0.color == .orange }
                .sorted { $0.position < $1.position }
            let redSkills = skillInputs.filter { $0.color == .red }
                .sorted { $0.position < $1.position }
            
            // Update positions by color group
            var currentPosition = 0
            
            // Process blue skills first
            for skill in blueSkills {
                if let index = skillInputs.firstIndex(where: { $0.id == skill.id }) {
                    skillInputs[index].position = currentPosition
                    currentPosition += 1
                }
            }
            
            // Then orange skills
            for skill in orangeSkills {
                if let index = skillInputs.firstIndex(where: { $0.id == skill.id }) {
                    skillInputs[index].position = currentPosition
                    currentPosition += 1
                }
            }
            
            // Finally red skills
            for skill in redSkills {
                if let index = skillInputs.firstIndex(where: { $0.id == skill.id }) {
                    skillInputs[index].position = currentPosition
                    currentPosition += 1
                }
            }
        }
    }
    
    private func saveCharacter() {
        let trimmedName = name.trimmingCharacters(in: .whitespacesAndNewlines)
        
        // Process skill inputs, cleaning names and preserving descriptions, colors, and positions
        let cleanedSkills = skillInputs
            .map { (name: $0.name.trimmingCharacters(in: .whitespacesAndNewlines), 
                   skillDescription: $0.skillDescription.trimmingCharacters(in: .whitespacesAndNewlines),
                   color: $0.color,
                   position: $0.position) }
            .filter { !$0.name.isEmpty }
        
        if trimmedName.isEmpty {
            errorMessage = "Please enter a character name"
            showingValidationAlert = true
            return
        }
        
        if cleanedSkills.isEmpty {
            errorMessage = "Please add at least one skill"
            showingValidationAlert = true
            return
        }
        
        let trimmedSet = set.isEmpty ? nil : set.trimmingCharacters(in: .whitespacesAndNewlines)
        let trimmedNotes = notes.isEmpty ? nil : notes.trimmingCharacters(in: .whitespacesAndNewlines)
        
        // Debug start - log save character
        print("SAVE CHARACTER - Saving \(cleanedSkills.count) skills:")
        for skill in cleanedSkills {
            print("- \(skill.name) (Color: \(skill.color), Position: \(skill.position))")
        }
        
        if let existingCharacter = character {
            // Update existing character basic info
            existingCharacter.name = trimmedName
            existingCharacter.set = trimmedSet
            existingCharacter.notes = trimmedNotes
            existingCharacter.isFavorite = isFavorite
            
            // SIMPLIFIED SKILL UPDATE - Don't try to reuse existing skills from the database
            // First, clear existing skills array to avoid duplicates
            if let existingSkills = existingCharacter.skills {
                print("Clearing \(existingSkills.count) existing skills")
                
                // Remove this character from each skill's characters array
                for skill in existingSkills {
                    skill.characters?.removeAll { $0.id == existingCharacter.id }
                }
                
                // Clear the character's skills array
                existingCharacter.skills?.removeAll()
            }
            
            // Now add all skills fresh
            for skillData in cleanedSkills {
                // Create a new skill with the cleaned data - ensure position is preserved
                let newSkill = Skill(
                    name: skillData.name,
                    skillDescription: skillData.skillDescription,
                    position: skillData.position,
                    manual: true,
                    color: skillData.color
                )
                
                // Debug position info
                print("Creating skill \(skillData.name) with position \(skillData.position)")
                
                // Insert the new skill
                context.insert(newSkill)
                
                // Initialize the characters array if needed
                if newSkill.characters == nil {
                    newSkill.characters = []
                }
                
                // Add this character to the skill's characters
                newSkill.characters?.append(existingCharacter)
                
                // Add the skill to the character's skills
                if existingCharacter.skills == nil {
                    existingCharacter.skills = []
                }
                
                existingCharacter.skills?.append(newSkill)
                
                print("Added new skill: \(newSkill.name) with position \(newSkill.position)")
            }
        } else {
            // Create new character
            let newCharacter = Character(
                name: trimmedName,
                set: trimmedSet,
                notes: trimmedNotes,
                isFavorite: isFavorite
            )
            context.insert(newCharacter)
            
            // Initialize the skills array
            newCharacter.skills = []
            
            // Add all skills
            for skillData in cleanedSkills {
                // Create a new skill with the cleaned data - ensure position is preserved
                let newSkill = Skill(
                    name: skillData.name,
                    skillDescription: skillData.skillDescription,
                    position: skillData.position,
                    manual: true,
                    color: skillData.color
                )
                
                // Debug position info
                print("Creating skill \(skillData.name) with position \(skillData.position)")
                
                // Insert the new skill
                context.insert(newSkill)
                
                // Initialize the characters array
                newSkill.characters = [newCharacter]
                
                // Add the skill to character's skills
                newCharacter.skills?.append(newSkill)
                
                print("Added new skill: \(newSkill.name) with position \(newSkill.position)")
            }
        }
        
        // Try to save changes to persist the data
        do {
            try context.save()
            print("Successfully saved character data")
        } catch {
            print("Failed to save character data: \(error)")
        }
        
        dismiss()
    }
}

#Preview {
    NavigationStack {
        AddCharacterView()
    }
}


----- FILE: /Users/steve/Library/Mobile Documents/com~apple~CloudDocs/AppProjects/ActionTracker/ActionTracker/SkillView.swift -----
//
//  SkillView.swift
//  ActionTracker
//
//  Created by Stephen Parker on 4/19/25.
//

import SwiftUI
import SwiftData

struct SkillView: View {
    @Environment(\.modelContext) private var context
    @Query var skills: [Skill]
    @State private var searchText = ""
    
    // Section expand/collapse state (only for headers)
    @State private var isActiveSkillsExpanded = true
    @State private var isUnusedSkillsExpanded = true
    
    var filteredSkills: [Skill] {
        guard !searchText.isEmpty else { return skills }
        return skills.filter {
            $0.name.localizedCaseInsensitiveContains(searchText) ||
            $0.skillDescription.localizedCaseInsensitiveContains(searchText)
        }
    }
    
    var orphanedSkills: [Skill] {
        filteredSkills.filter { $0.characters == nil || $0.characters!.isEmpty }
    }
    
    var activeSkills: [Skill] {
        filteredSkills.filter { $0.characters != nil && !$0.characters!.isEmpty }
    }
    
    var body: some View {
        NavigationStack {
            List {
                // Active Skills Section with collapsible header
                DisclosureGroup(
                    isExpanded: $isActiveSkillsExpanded,
                    content: {
                        if activeSkills.isEmpty {
                            Text("No active skills found")
                                .foregroundColor(.secondary)
                        } else {
                            ForEach(activeSkills.sorted(by: { $0.name < $1.name })) { skill in
                                SkillItemView(skill: skill)
                            }
                        }
                    },
                    label: {
                        Text("Active Skills (\(activeSkills.count))")
                            .font(.headline)
                    }
                )
                
                // Unused Skills Section with collapsible header
                DisclosureGroup(
                    isExpanded: $isUnusedSkillsExpanded,
                    content: {
                        if orphanedSkills.isEmpty {
                            Text("No unused skills found")
                                .foregroundColor(.secondary)
                        } else {
                            ForEach(orphanedSkills.sorted(by: { $0.name < $1.name })) { skill in
                                SkillItemView(skill: skill)
                                    .swipeActions(edge: .trailing) {
                                        Button(role: .destructive) {
                                            withAnimation {
                                                // Only delete skills with no characters
                                                if skill.characters == nil || skill.characters!.isEmpty {
                                                    context.delete(skill)
                                                }
                                            }
                                        } label: {
                                            Label("Delete", systemImage: "trash")
                                        }
                                    }
                            }
                        }
                    },
                    label: {
                        Text("Unused Skills (\(orphanedSkills.count))")
                            .font(.headline)
                    }
                )
            }
            .searchable(text: $searchText)
            .navigationTitle("Skill Library")
        }
    }
}

struct SkillItemView: View {
    let skill: Skill
    @State private var showingDetail = false
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text(skill.name)
                .font(.headline)
            
            if !skill.skillDescription.isEmpty {
                Text(skill.skillDescription)
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .fixedSize(horizontal: false, vertical: true) // Allow proper wrapping
            }
            
            if skill.characters != nil && !skill.characters!.isEmpty {
                Text("Used by: \(characterNames)")
                    .font(.caption2)
                    .foregroundColor(.blue)
                    .fixedSize(horizontal: false, vertical: true) // Allow proper wrapping
            }
        }
        .padding(.vertical, 4)
        .onTapGesture {
            showingDetail.toggle()
        }
        .sheet(isPresented: $showingDetail) {
            SkillDetailView(skill: skill)
        }
    }
    
    private var characterNames: String {
        (skill.characters ?? [])
            .map { $0.name }
            .sorted()
            .joined(separator: ", ")
    }
}

struct SkillDetailView: View {
    let skill: Skill
    @Environment(\.dismiss) private var dismiss
    @Environment(\.modelContext) private var context
    
    @State private var editedName: String
    @State private var editedDescription: String
    @State private var isEditing = false
    
    init(skill: Skill) {
        self.skill = skill
        _editedName = State(initialValue: skill.name)
        _editedDescription = State(initialValue: skill.skillDescription)
    }
    
    var body: some View {
        NavigationStack {
            Form {
                Section("Skill Information") {
                    if isEditing {
                        TextField("Name", text: $editedName)
                            .textInputAutocapitalization(.words)
                        
                        VStack(alignment: .leading, spacing: 4) {
                            Text("Description")
                                .font(.caption)
                                .foregroundColor(.secondary)
                            
                            // Enhanced multi-line text field for description
                            TextEditor(text: $editedDescription)
                                .font(.body)
                                .frame(minHeight: 100)
                                .padding(4)
                                .background(Color(.systemGray6))
                                .cornerRadius(8)
                                .textInputAutocapitalization(.sentences)
                        }
                    } else {
                        LabeledContent("Name", value: skill.name)
                        
                        if !skill.skillDescription.isEmpty {
                            VStack(alignment: .leading, spacing: 4) {
                                Text("Description")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                                
                                Text(skill.skillDescription)
                                    .fixedSize(horizontal: false, vertical: true) // Allow proper wrapping
                            }
                        }
                    }
                    
                    LabeledContent("Manually Created", value: skill.manual ? "Yes" : "No")
                    LabeledContent("Imported", value: skill.importedFlag ? "Yes" : "No")
                }
                
                if skill.characters != nil && !skill.characters!.isEmpty {
                    Section("Used By Characters") {
                        ForEach((skill.characters ?? []).sorted(by: { $0.name < $1.name })) { character in
                            VStack(alignment: .leading) {
                                Text(character.name)
                                    .font(.subheadline)
                                
                                if let set = character.set, !set.isEmpty {
                                    Text(set)
                                        .font(.caption)
                                        .foregroundColor(.secondary)
                                }
                            }
                        }
                    }
                }
            }
            .navigationTitle("Skill Detail")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Done") {
                        dismiss()
                    }
                }
                
                ToolbarItem(placement: .navigationBarTrailing) {
                    if isEditing {
                        Button("Save") {
                            // Only update if values have changed
                            if editedName != skill.name || editedDescription != skill.skillDescription {
                                // Normalize the skill name
                                skill.name = Skill.normalizeSkillName(editedName)
                                
                                // Clean up whitespace in description
                                let cleanDescription = editedDescription.trimmingCharacters(in: .whitespacesAndNewlines)
                                    .replacingOccurrences(of: "\\s+", with: " ", options: .regularExpression)
                                
                                skill.skillDescription = cleanDescription
                                try? context.save()
                            }
                            isEditing = false
                        }
                    } else {
                        Button("Edit") {
                            isEditing = true
                        }
                    }
                }
            }
        }
    }
}

#Preview {
    SkillView()
}

----- FILE: /Users/steve/Library/Mobile Documents/com~apple~CloudDocs/AppProjects/ActionTracker/ActionTracker/CustomContext.swift -----
//
//  Context.swift
//  ZombicideCharacters
//
//  Created by Stephen Parker on 4/12/25.
//

import SwiftUI
import SwiftData

class CustomContext: NSObject, UIDocumentPickerDelegate {
    static let shared = CustomContext()
    private var modelContext: ModelContext?
    private var importCompletionHandler: (() -> Void)?

    func configure(with context: ModelContext, completion: (() -> Void)? = nil) {
        self.modelContext = context
        self.importCompletionHandler = completion
    }

    func documentPicker(_ controller: UIDocumentPickerViewController, didPickDocumentsAt urls: [URL]) {
        guard let url = urls.first, let context = self.modelContext else { 
            print("ModelContext not available")
            return 
        }

        guard url.startAccessingSecurityScopedResource() else {
            print("Failed to access security-scoped resource.")
            return
        }

        defer { url.stopAccessingSecurityScopedResource() } //  Clean up after

        do {
            print("==== IMPORT STARTED: Current context = \(context) ====")
            
            // Delete existing characters first - handle with care
            let existingCharacters = try context.fetch(FetchDescriptor<Character>())
            print("Found \(existingCharacters.count) existing characters to delete")
            
            for character in existingCharacters {
                context.delete(character)
            }
            
            // Save the deletion before continuing
            try context.save()
            print("Deleted all existing characters")

            let content = try String(contentsOf: url, encoding: .utf8)
            let rows = content.components(separatedBy: CharacterSet.newlines).dropFirst()
            
            // Parse and insert new characters
            for line in rows {
                guard !line.trimmingCharacters(in: .whitespaces).isEmpty else { continue }
                let columns = parseCSVLine(line)
                guard columns.count >= 6 else { continue } // New format requires 6 columns (Name,Set,Notes,Blue,Orange,Red)

                // Clean and normalize input data
                let rawName = columns[0].trimmingCharacters(in: .whitespacesAndNewlines)
                let name = rawName.replacingOccurrences(of: "\\s+", with: " ", options: .regularExpression)
                
                let rawSet = columns[1].trimmingCharacters(in: .whitespacesAndNewlines)
                let set = rawSet.isEmpty ? nil : rawSet.replacingOccurrences(of: "\\s+", with: " ", options: .regularExpression)
                
                let rawNotes = columns[2].trimmingCharacters(in: .whitespacesAndNewlines)
                let notes = rawNotes.isEmpty ? nil : rawNotes.replacingOccurrences(of: "\\s+", with: " ", options: .regularExpression)
                
                // Process each color of skills separately
                let blueSkills = parseSkillList(columns[3])
                let orangeSkills = parseSkillList(columns[4])
                let redSkills = parseSkillList(columns[5])

                // Create the character with all its skills
                let newChar = Character(name: name, set: set, notes: notes, 
                                        blueSkills: blueSkills, 
                                        orangeSkills: orangeSkills, 
                                        redSkills: redSkills)
                
                context.insert(newChar)
                
                // Blue skills are already marked as active in the Character initializer
                
                // We're going to completely avoid looking up or creating relationships 
                // with existing skills to prevent cross-contamination issues
                
                // Just to be safe, make sure each character has their own independent skills with no shared references
                print("IMPORT: Character \(newChar.name) has \(newChar.skills?.count ?? 0) skills")
                
                // Delete any skills that this character shouldn't have (sanity check)
                // If the skill's name is not in any of the color lists, remove it
                if let skills = newChar.skills {
                    var skillsToRemove = [UUID]()
                    
                    for skill in skills {
                        let skillName = skill.name
                        let skillColor = skill.color
                        
                        // Check if this skill should belong to this character
                        var shouldKeep = false
                        
                        switch skillColor {
                        case .blue:
                            shouldKeep = newChar.blueSkills.contains(skillName)
                        case .orange:
                            shouldKeep = newChar.orangeSkills.contains(skillName)
                        case .red:
                            shouldKeep = newChar.redSkills.contains(skillName)
                        case .none:
                            shouldKeep = false
                        }
                        
                        if !shouldKeep {
                            print("REMOVING INVALID SKILL: \(skillName) (\(String(describing: skillColor))) from \(newChar.name)")
                            skillsToRemove.append(skill.id)
                        }
                    }
                    
                    // Remove invalid skills
                    for skillID in skillsToRemove {
                        if let index = newChar.skills?.firstIndex(where: { $0.id == skillID }) {
                            let skillToRemove = newChar.skills?[index]
                            newChar.skills?.remove(at: index)
                            if let skillToRemove = skillToRemove {
                                context.delete(skillToRemove)
                            }
                        }
                    }
                }
                
                // Final verification
                print("IMPORT: After cleanup, \(newChar.name) has \(newChar.skills?.count ?? 0) skills")
                
                if let skills = newChar.skills {
                    for skill in skills {
                        print("IMPORT: \(newChar.name) has skill: \(skill.name) (color: \(String(describing: skill.color)), position: \(skill.position))")
                    }
                }
            }
            
            // Save changes immediately
            try context.save()
            
            // Double-check the fetch after save to verify persistence
            let verifyDescriptor = FetchDescriptor<Character>()
            let verifyResults = try context.fetch(verifyDescriptor)
            let verifyCount = verifyResults.count
            
            print("Verified after save: \(verifyCount) characters in context")
            if verifyCount > 0 {
                // Print the first 5 character names to verify content
                let names = verifyResults.prefix(5).map { $0.name }.joined(separator: ", ")
                print("First 5 character names: \(names)")
            }
            
            // Call completion handler if provided
            DispatchQueue.main.async {
                self.importCompletionHandler?()
                
                // Post a notification for any observers that data has changed
                NotificationCenter.default.post(name: NSNotification.Name("RefreshCharacterData"), object: nil)
            }
            
            print("Import successful: \(rows.count) characters")
        } catch {
            print("Import failed: \(error)")
        }
    }
    
    // Helper function to parse a semicolon-separated list of skills
    private func parseSkillList(_ skillsString: String) -> [String] {
        return skillsString.split(separator: ";").map { skillName -> String in
            let trimmed = skillName.trimmingCharacters(in: .whitespacesAndNewlines)
            return trimmed.replacingOccurrences(of: "\\s+", with: " ", options: .regularExpression)
        }
    }

    private func parseCSVLine(_ line: String) -> [String] {
        var results: [String] = []
        var value = ""
        var insideQuotes = false

        var iterator = line.makeIterator()
        while let char = iterator.next() {
            switch char {
            case "\"":
                insideQuotes.toggle()
            case ",":
                if insideQuotes {
                    value.append(char)
                } else {
                    results.append(value)
                    value = ""
                }
            default:
                value.append(char)
            }
        }
        results.append(value)
        return results.map { $0.replacingOccurrences(of: "\"\"", with: "\"") }
    }
}


----- FILE: /Users/steve/Library/Mobile Documents/com~apple~CloudDocs/AppProjects/ActionTracker/ActionTracker/SkillManagerView.swift -----
//
//  SkillManagerView.swift
//  ActionTracker
//
//  Created by Stephen Parker on 4/27/25.
//

import SwiftUI
import SwiftData
import Observation

struct SkillManagerView: View {
    @Environment(\.dismiss) private var dismiss
    @Environment(\.modelContext) private var context
    @EnvironmentObject private var appViewModel: AppViewModel
    
    var character: Character
    let experience: Int
    
    var body: some View {
        NavigationStack {
            Form {
                Section("Character") {
                    HStack {
                        Text(character.name)
                            .font(.headline)
                        
                        if let set = character.set, !set.isEmpty {
                            Text("(\(set))")
                                .font(.subheadline)
                                .foregroundColor(.secondary)
                        }
                    }
                }
                
                // Blue Skills - always active by default
                Section("Blue Skills") {
                    if character.blueSkills.isEmpty {
                        Text("No blue skills available")
                            .foregroundColor(.secondary)
                    } else {
                        ForEach(character.blueSkills, id: \.self) { skill in
                            SkillToggleRow(
                                skill: skill,
                                isActive: character.activeBlueSkills.contains(skill),
                                color: .skillBlue,
                                isEnabled: true,
                                toggleAction: { isActive in
                                    if isActive {
                                        character.activateSkill(name: skill, color: .blue)
                                    } else {
                                        character.deactivateSkill(name: skill, color: .blue)
                                    }
                                    try? context.save()
                                }
                            )
                        }
                    }
                }
                
                // Orange Skills - available at XP 19
                let orangeSkillsAllowed = appViewModel.getMaxOrangeSkills()
                Section(header: Text("Orange Skills (Available at XP 19+)")) {
                    if character.orangeSkills.isEmpty {
                        Text("No orange skills available")
                            .foregroundColor(.secondary)
                    } else {
                        if experience < 19 {
                            Text("Character hasn't reached Orange skill level yet (XP 19)")
                                .font(.caption)
                                .foregroundColor(.secondary)
                                .padding(.vertical, 4)
                        } else {
                            Text("Can select \(orangeSkillsAllowed) orange skill(s)")
                                .font(.caption)
                                .foregroundColor(.secondary)
                                .padding(.vertical, 4)
                        }
                        
                        ForEach(character.orangeSkills, id: \.self) { skill in
                            SkillToggleRow(
                                skill: skill,
                                isActive: character.activeOrangeSkills.contains(skill),
                                color: .skillOrange,
                                isEnabled: experience >= 19 && 
                                          (character.activeOrangeSkills.contains(skill) || 
                                           character.activeOrangeSkills.count < orangeSkillsAllowed),
                                toggleAction: { isActive in
                                    if isActive {
                                        character.activateSkill(name: skill, color: .orange)
                                    } else {
                                        character.deactivateSkill(name: skill, color: .orange)
                                    }
                                    try? context.save()
                                }
                            )
                        }
                    }
                }
                
                // Red Skills - available at XP 43
                let redSkillsAllowed = appViewModel.getMaxRedSkills()
                Section(header: Text("Red Skills (Available at XP 43+)")) {
                    if character.redSkills.isEmpty {
                        Text("No red skills available")
                            .foregroundColor(.secondary)
                    } else {
                        if experience < 43 {
                            Text("Character hasn't reached Red skill level yet (XP 43)")
                                .font(.caption)
                                .foregroundColor(.secondary)
                                .padding(.vertical, 4)
                        } else {
                            Text("Can select \(redSkillsAllowed) red skill(s)")
                                .font(.caption)
                                .foregroundColor(.secondary)
                                .padding(.vertical, 4)
                        }
                        
                        ForEach(character.redSkills, id: \.self) { skill in
                            SkillToggleRow(
                                skill: skill,
                                isActive: character.activeRedSkills.contains(skill),
                                color: .skillRed,
                                isEnabled: experience >= 43 && 
                                          (character.activeRedSkills.contains(skill) || 
                                           character.activeRedSkills.count < redSkillsAllowed),
                                toggleAction: { isActive in
                                    if isActive {
                                        character.activateSkill(name: skill, color: .red)
                                    } else {
                                        character.deactivateSkill(name: skill, color: .red)
                                    }
                                    try? context.save()
                                }
                            )
                        }
                    }
                }
            }
            .navigationTitle("Manage Skills")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                }
            }
        }
    }
}

// Row component for toggling a skill - optimized with equatable
struct SkillToggleRow: View, Equatable {
    let skill: String
    let isActive: Bool
    let color: Color
    let isEnabled: Bool
    let toggleAction: (Bool) -> Void
    
    // For efficient SwiftUI rendering with ForEach
    static func == (lhs: SkillToggleRow, rhs: SkillToggleRow) -> Bool {
        return lhs.skill == rhs.skill &&
               lhs.isActive == rhs.isActive &&
               lhs.isEnabled == rhs.isEnabled
    }
    
    var body: some View {
        HStack {
            Toggle(isOn: Binding(
                get: { isActive },
                set: { toggleAction($0) }
            )) {
                Text(skill)
                    .foregroundColor(isEnabled ? .primary : .secondary)
            }
            .tint(color)
            .disabled(!isEnabled)
        }
        // Add id for stable identity in views
        .id("skill_toggle_\(skill)_\(isActive ? "active" : "inactive")")
    }
}

#Preview {
    struct PreviewWrapper: View {
        @State private var mockCharacter: Character?
        
        var body: some View {
            VStack {
                if let character = mockCharacter {
                    SkillManagerView(
                        character: character,
                        experience: 45
                    )
                } else {
                    Text("Loading preview...")
                        .onAppear {
                            let character = Character(
                                name: "Preview Character",
                                blueSkills: ["Zombie Link", "Taunt"],
                                orangeSkills: ["+1 Die: Combat", "+1 To Dice Roll: Melee"],
                                redSkills: ["+1 Damage: Combat", "+1 Free Action: Combat"]
                            )
                            
                            mockCharacter = character
                        }
                }
            }
        }
    }
    
    return PreviewWrapper()
}

----- FILE: /Users/steve/Library/Mobile Documents/com~apple~CloudDocs/AppProjects/ActionTracker/ActionTracker/CharacterSeeder.swift -----
//
//  CharacterSeeder.swift
//  ActionTracker
//
//  Created by Stephen Parker on 4/11/25.
//

import SwiftUI
import SwiftData

struct CharacterSeeder: ViewModifier {
    @Environment(\.modelContext) private var context
    @Query var existing: [Character]
    @State private var hasAttemptedSeed = false
    
    // Key for UserDefaults to track first launch
    private let hasLaunchedBeforeKey = "ActionTracker.hasLaunchedBefore"

    func body(content: Content) -> some View {
        content
            .onAppear {
                // Check if app has been launched before
                let hasLaunchedBefore = UserDefaults.standard.bool(forKey: hasLaunchedBeforeKey)
                
                // Only proceed if this is the first launch
                if !hasLaunchedBefore {
                    print("First app launch detected, preparing to seed data...")
                    // Add a delay to ensure modelContext is properly set up
                    DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
                        // Only seed if there are no existing characters AND we haven't attempted to seed yet
                        if !hasAttemptedSeed && existing.isEmpty {
                            // Check if any skills already exist - if so, don't seed
                            let skillDescriptor = FetchDescriptor<Skill>()
                            do {
                                let existingSkills = try context.fetch(skillDescriptor)
                                if existingSkills.isEmpty {
                                    hasAttemptedSeed = true
                                    seedCharacters()
                                    
                                    // Set flag that app has been launched before
                                    UserDefaults.standard.set(true, forKey: hasLaunchedBeforeKey)
                                } else {
                                    print("Skills already exist, skipping seeding")
                                    
                                    // Normalize existing skill names on app startup
                                    normalizeExistingSkillNames(existingSkills)
                                    
                                    hasAttemptedSeed = true
                                    UserDefaults.standard.set(true, forKey: hasLaunchedBeforeKey)
                                }
                            } catch {
                                print("Error checking for existing skills: \(error)")
                                // Proceed with seeding if we can't check
                                hasAttemptedSeed = true
                                seedCharacters()
                                UserDefaults.standard.set(true, forKey: hasLaunchedBeforeKey)
                            }
                        } else {
                            // If we have characters already, mark the app as launched
                            UserDefaults.standard.set(true, forKey: hasLaunchedBeforeKey)
                        }
                    }
                } else {
                    print("App has launched before, skipping initial seed data")
                }
            }
            .task {
                // Secondary attempt only if it's the first launch and the first attempt failed
                if !UserDefaults.standard.bool(forKey: hasLaunchedBeforeKey) && !hasAttemptedSeed && existing.isEmpty {
                    try? await Task.sleep(for: .seconds(2))
                    
                    let skillDescriptor = FetchDescriptor<Skill>()
                    do {
                        let existingSkills = try context.fetch(skillDescriptor)
                        if existingSkills.isEmpty {
                            hasAttemptedSeed = true
                            seedCharacters()
                            UserDefaults.standard.set(true, forKey: hasLaunchedBeforeKey)
                        } else {
                            print("Skills already exist, skipping seeding")
                            
                            // Normalize existing skill names on app startup
                            normalizeExistingSkillNames(existingSkills)
                            
                            hasAttemptedSeed = true
                            UserDefaults.standard.set(true, forKey: hasLaunchedBeforeKey)
                        }
                    } catch {
                        print("Error checking for existing skills: \(error)")
                        // Proceed with seeding if we can't check
                        hasAttemptedSeed = true
                        seedCharacters()
                        UserDefaults.standard.set(true, forKey: hasLaunchedBeforeKey)
                    }
                }
            }
    }

    // Normalizes all existing skill names to ensure consistent capitalization
    private func normalizeExistingSkillNames(_ skills: [Skill]) {
        print("Normalizing existing skill names...")
        
        var changesMade = false
        
        // Go through each skill and normalize its name
        for skill in skills {
            let currentName = skill.name
            let normalizedName = Skill.normalizeSkillName(currentName)
            
            // If the name is different after normalization, update it
            if currentName != normalizedName {
                print("Normalizing skill name from '\(currentName)' to '\(normalizedName)'")
                skill.name = normalizedName
                changesMade = true
            }
        }
        
        // Save changes if needed
        if changesMade {
            do {
                try context.save()
                print("Successfully normalized skill names")
            } catch {
                print("Error saving normalized skill names: \(error)")
            }
        } else {
            print("No skill name normalization needed")
        }
    }
    
    private func seedCharacters() {
        print("Seeding initial character data...")
        
        // Define character data with skill names and descriptions
        // For each character, we'll group skills by color
        
        // Fred's skills by color
        let fredBlueSkills: [(name: String, description: String)] = [
            ("Reaper: Combat", "Deal 1 damage to all Zombies in the same zone after combat"),
            ("+1 Free Combat Action", "Get one additional combat action per turn")
        ]
        
        let fredOrangeSkills: [(name: String, description: String)] = [
            ("Dreadnought: Walker", "Walker attacks do not cause damage to this character"),
            ("+1 Die: Combat", "Add 1 die to combat rolls")
        ]
        
        let fredRedSkills: [(name: String, description: String)] = [
            ("+1 Free Combat Action", "Get one additional combat action per turn"),
            ("+1 To Dice Roll: Combat", "Add 1 to each die rolled in combat")
        ]
        
        // Bunny's skills by color
        let bunnyBlueSkills: [(name: String, description: String)] = [
            ("Lucky", "Re-roll one failed die per turn"),
            ("+1 To Dice Roll: Melee", "Add 1 to each melee die roll")
        ]
        
        let bunnyOrangeSkills: [(name: String, description: String)] = [
            ("Jump", "Move through zones with zombies without spending extra actions"),
            ("+1 Damage: Melee", "Add 1 damage to successful melee attacks")
        ]
        
        let bunnyRedSkills: [(name: String, description: String)] = [
            ("+1 Free Combat Action", "Get one additional combat action per turn"),
            ("Roll 6: +1 Die Combat", "When rolling a 6 in combat, get an extra die")
        ]
        
        // Tiger's skills by color
        let tigerBlueSkills: [(name: String, description: String)] = [
            ("+1 Die: Ranged", "Add 1 die to ranged attack rolls"),
            ("+1 Free Move Action", "Get one additional move action per turn")
        ]
        
        let tigerOrangeSkills: [(name: String, description: String)] = [
            ("Sniper", "Ignore range penalties when using ranged weapons"),
            ("+1 Damage: Ranged", "Add 1 damage to successful ranged attacks")
        ]
        
        let tigerRedSkills: [(name: String, description: String)] = [
            ("+1 Free Combat Action", "Get one additional combat action per turn"),
            ("Shove", "Push zombies to an adjacent zone once per turn")
        ]
        
        // Extract skill names for Character initialization
        let fredBlueSkillNames = fredBlueSkills.map { $0.name }
        let fredOrangeSkillNames = fredOrangeSkills.map { $0.name }
        let fredRedSkillNames = fredRedSkills.map { $0.name }
        
        let bunnyBlueSkillNames = bunnyBlueSkills.map { $0.name }
        let bunnyOrangeSkillNames = bunnyOrangeSkills.map { $0.name }
        let bunnyRedSkillNames = bunnyRedSkills.map { $0.name }
        
        let tigerBlueSkillNames = tigerBlueSkills.map { $0.name }
        let tigerOrangeSkillNames = tigerOrangeSkills.map { $0.name }
        let tigerRedSkillNames = tigerRedSkills.map { $0.name }
        
        // Create characters with their skills
        let fred = Character(
            name: "Fred",
            blueSkills: fredBlueSkillNames,
            orangeSkills: fredOrangeSkillNames,
            redSkills: fredRedSkillNames
        )
        
        let bunny = Character(
            name: "Bunny G",
            blueSkills: bunnyBlueSkillNames,
            orangeSkills: bunnyOrangeSkillNames,
            redSkills: bunnyRedSkillNames
        )
        
        let tiger = Character(
            name: "Tiger Sam",
            blueSkills: tigerBlueSkillNames,
            orangeSkills: tigerOrangeSkillNames,
            redSkills: tigerRedSkillNames
        )
        
        // Insert characters into context
        context.insert(fred)
        context.insert(bunny)
        context.insert(tiger)
        
        // Skill creation helper function
        func createSkillIfNeeded(name: String, description: String, color: SkillColor, position: Int, character: Character) {
            // First normalize using the static method
            let normalizedName = Skill.normalizeSkillName(name)
            
            // Check if skill already exists
            var descriptor = FetchDescriptor<Skill>()
            descriptor.predicate = #Predicate<Skill> { skill in
                skill.name == normalizedName
            }
            
            do {
                if let existingSkill = try context.fetch(descriptor).first {
                    // Use existing skill
                    if existingSkill.skillDescription.isEmpty {
                        existingSkill.skillDescription = description
                    }
                    
                    // Ensure character relationship
                    if existingSkill.characters == nil {
                        existingSkill.characters = []
                    }
                    
                    if !existingSkill.characters!.contains(where: { $0.id == character.id }) {
                        existingSkill.characters?.append(character)
                    }
                } else {
                    // Create new skill
                    let newSkill = Skill(
                        name: name,
                        skillDescription: description,
                        position: position,
                        manual: false,
                        color: color
                    )
                    context.insert(newSkill)
                    
                    // Set up relationship
                    if newSkill.characters == nil {
                        newSkill.characters = []
                    }
                    newSkill.characters?.append(character)
                    
                    // The Character init has already created the skills,
                    // but we need to ensure our new skill objects are linked
                    // Back-reference not needed since Character already has the skills
                }
            } catch {
                print("Error checking for existing skill '\(name)': \(error)")
                
                // Create new skill as fallback
                let newSkill = Skill(
                    name: name, 
                    skillDescription: description,
                    position: position,
                    manual: false,
                    color: color
                )
                context.insert(newSkill)
                
                // Set up relationship
                if newSkill.characters == nil {
                    newSkill.characters = []
                }
                newSkill.characters?.append(character)
            }
        }
        
        // Process Fred's skills
        var position = 0
        for (name, description) in fredBlueSkills {
            createSkillIfNeeded(name: name, description: description, color: .blue, position: position, character: fred)
            position += 1
        }
        for (name, description) in fredOrangeSkills {
            createSkillIfNeeded(name: name, description: description, color: .orange, position: position, character: fred)
            position += 1
        }
        for (name, description) in fredRedSkills {
            createSkillIfNeeded(name: name, description: description, color: .red, position: position, character: fred)
            position += 1
        }
        
        // Process Bunny's skills
        position = 0
        for (name, description) in bunnyBlueSkills {
            createSkillIfNeeded(name: name, description: description, color: .blue, position: position, character: bunny)
            position += 1
        }
        for (name, description) in bunnyOrangeSkills {
            createSkillIfNeeded(name: name, description: description, color: .orange, position: position, character: bunny)
            position += 1
        }
        for (name, description) in bunnyRedSkills {
            createSkillIfNeeded(name: name, description: description, color: .red, position: position, character: bunny)
            position += 1
        }
        
        // Process Tiger's skills
        position = 0
        for (name, description) in tigerBlueSkills {
            createSkillIfNeeded(name: name, description: description, color: .blue, position: position, character: tiger)
            position += 1
        }
        for (name, description) in tigerOrangeSkills {
            createSkillIfNeeded(name: name, description: description, color: .orange, position: position, character: tiger)
            position += 1
        }
        for (name, description) in tigerRedSkills {
            createSkillIfNeeded(name: name, description: description, color: .red, position: position, character: tiger)
            position += 1
        }
        
        // Save changes
        do {
            try context.save()
            print("Successfully saved seed characters with their skills")
        } catch {
            print("Failed to save seed characters: \(error)")
        }
    }
}

----- FILE: /Users/steve/Library/Mobile Documents/com~apple~CloudDocs/AppProjects/ActionTracker/ActionTracker/SkillSearchView.swift -----
//
//  SkillSearchView.swift
//  ZombicideCharacters
//
//  Created by Stephen Parker on 4/11/25.
//

import SwiftUI
import SwiftData

struct SkillSearchView: View {
    @Query var allCharacters: [Character]
    @State private var selectedSkills: [String] = []
    @State private var searchResults: [Character] = []
    @State private var hasSearched = false
    @State private var selectedCharacter: Character?
    @Environment(\.dismiss) private var dismiss
    @Environment(\.modelContext) private var context

    // Returns filtered characters matching ALL selected skills, including group skills
    var filteredCharacters: [Character] {
        allCharacters.filter { character in
            let characterSkillNames = (character.skills ?? []).map { $0.name }
            
            return selectedSkills.allSatisfy { skill in
                if isGroupSkill(skill) {
                    // For a group skill, check if character has ANY of the skills in the group
                    let groupSkills = skillsInGroup(skill)
                    return !Set(characterSkillNames).isDisjoint(with: groupSkills)
                } else {
                    // For a regular skill, character must have the exact skill
                    return characterSkillNames.contains(skill)
                }
            }
        }
    }

    // Return skills available for the dropdown at given index position, including custom group skills
    func availableSkills(for index: Int) -> [String] {
        // For first dropdown show all skills, for subsequent dropdowns filter by current matches
        let characters = index == 0 ? allCharacters : filteredCharacters
        
        // Don't show skills already selected in previous dropdowns
        let usedSkills = Set(selectedSkills.prefix(index))
        
        // Get all skills from relevant characters
        let remainingSkills = characters.flatMap { ($0.skills ?? []).map { $0.name } }
        
        // Remove duplicates and already selected skills
        let uniqueRemaining = Set(remainingSkills).subtracting(usedSkills)
        
        // Create a dictionary to group skills by their prefix (up to the colon)
        var skillGroups: [String: [String]] = [:]
        
        // Process each skill to find common prefixes
        for skill in uniqueRemaining {
            if let colonIndex = skill.firstIndex(of: ":") {
                let prefix = String(skill[..<colonIndex]).trimmingCharacters(in: .whitespaces)
                if prefix.isEmpty { continue }
                
                if skillGroups[prefix] == nil {
                    skillGroups[prefix] = [skill]
                } else {
                    skillGroups[prefix]!.append(skill)
                }
            }
        }
        
        // Create the final list with group headers and individual skills
        var result: [String] = []
        
        // Add group skills to the top (only if they have more than one skill in the group)
        let groupPrefixes = skillGroups.filter { $0.value.count > 1 }
                                      .keys
                                      .sorted()
        
        for prefix in groupPrefixes {
            // Create a formatted group skill that's not actually a real skill but a group identifier
            let groupSkill = prefix
            result.append(groupSkill)
        }
        
        // Add all individual skills, sorted alphabetically
        let sortedSkills = Array(uniqueRemaining).sorted()
        result.append(contentsOf: sortedSkills)
        
        return result
    }
    
    // Get all skills that belong to a group prefix
    private func skillsInGroup(_ prefix: String) -> [String] {
        let allSkillsList = allCharacters.flatMap { ($0.skills ?? []).map { $0.name } }
        
        return allSkillsList.filter { skill in
            if let colonIndex = skill.firstIndex(of: ":") {
                let skillPrefix = String(skill[..<colonIndex]).trimmingCharacters(in: .whitespaces)
                return skillPrefix == prefix
            }
            return false
        }
    }
    
    // Check if a skill is a group header
    private func isGroupSkill(_ skill: String) -> Bool {
        // If it contains no colon but exists as a prefix for other skills
        if !skill.contains(":") {
            let grouped = skillsInGroup(skill)
            return !grouped.isEmpty
        }
        return false
    }

    var body: some View {
        ZStack {
            NavigationStack {
                VStack {
                    if allCharacters.isEmpty {
                        ContentUnavailableView(
                            "No Characters",
                            systemImage: "person.fill.questionmark",
                            description: Text("Add some characters first")
                        )
                        .padding(.top, 50)
                    } else {
                        Form {
                            Section("Select Skills") {
                                ForEach(0..<dropdownCount(), id: \.self) { index in
                                    let skills = availableSkills(for: index)
                                    if !skills.isEmpty {
                                        Picker("Skill \(index + 1)", selection: Binding(
                                            get: {
                                                if index < selectedSkills.count {
                                                    return selectedSkills[index]
                                                } else {
                                                    return ""
                                                }
                                            },
                                            set: { newValue in
                                                withAnimation {
                                                    // If changing an existing selection
                                                    if index < selectedSkills.count {
                                                        // If selection cleared, remove this and all subsequent selections
                                                        if newValue.isEmpty {
                                                            selectedSkills.removeSubrange(index...)
                                                        } else {
                                                            // Update with new selection
                                                            selectedSkills[index] = newValue
                                                            
                                                            // Only remove subsequent selections if we're not selecting a group skill
                                                            // or if the search results would be empty
                                                            let wouldHaveResults = !allCharacters.filter { character in
                                                                let characterSkills = (character.skills ?? []).map { $0.name }
                                                                let updatedSkills = selectedSkills.prefix(index + 1)
                                                                return updatedSkills.allSatisfy { skill in
                                                                    if isGroupSkill(skill) {
                                                                        return !Set(characterSkills).isDisjoint(with: skillsInGroup(skill))
                                                                    } else {
                                                                        return characterSkills.contains(skill)
                                                                    }
                                                                }
                                                            }.isEmpty
                                                            
                                                            if !isGroupSkill(newValue) || !wouldHaveResults {
                                                                if selectedSkills.count > index + 1 {
                                                                    selectedSkills.removeSubrange((index + 1)...)
                                                                }
                                                            }
                                                        }
                                                    } else if !newValue.isEmpty {
                                                        // Adding a new selection
                                                        selectedSkills.append(newValue)
                                                    }
                                                    performSearch()
                                                }
                                            })) {
                                            Text("Select a skill").tag("")
                                            ForEach(skills, id: \.self) { skill in
                                                if isGroupSkill(skill) {
                                                    // Display group skills with bold text and an indicator
                                                    Text("\(skill) (Group)")
                                                        .bold()
                                                        .tag(skill)
                                                } else {
                                                    Text(skill).tag(skill)
                                                }
                                            }
                                        }
                                        .pickerStyle(MenuPickerStyle())
                                    }
                                }
                                
                                if !selectedSkills.isEmpty {
                                    Button(role: .destructive) {
                                        withAnimation {
                                            selectedSkills.removeAll()
                                            performSearch()
                                        }
                                    } label: {
                                        Label("Clear All Selections", systemImage: "xmark.circle")
                                    }
                                }
                            }

                            if hasSearched {
                                Section {
                                    if searchResults.isEmpty {
                                        Text("No characters found with all selected skills.")
                                            .foregroundColor(.secondary)
                                            .frame(maxWidth: .infinity, alignment: .center)
                                            .padding()
                                    } else {
                                        Text("Found \(searchResults.count) character\(searchResults.count == 1 ? "" : "s")")
                                            .foregroundColor(.secondary)
                                            .font(.caption)
                                    }
                                }
                                
                                if !searchResults.isEmpty {
                                    Section("Results") {
                                        // Results are already sorted in performSearch()
                                        ForEach(searchResults) { character in
                                            Button {
                                                selectedCharacter = character
                                            } label: {
                                                VStack(alignment: .leading, spacing: 4) {
                                                    Text(character.set?.isEmpty == false ? "\(character.name) (\(character.set!))" : character.name)
                                                        .font(.headline)
                                                    
                                                    // Highlight matched skills in the results
                                                    SkillsView(
                                                        allSkills: (character.skills ?? []).sorted { $0.position < $1.position }.map { $0.name }, 
                                                        highlightSkills: selectedSkills
                                                    )
                                                }
                                                .padding(.vertical, 4)
                                                .foregroundColor(.primary)
                                            }
                                        }
                                    }
                                }
                            } else {
                                Section {
                                    Text("Found \(allCharacters.count) character\(searchResults.count == 1 ? "" : "s")")
                                        .foregroundColor(.secondary)
                                        .font(.caption)
                                }
                            }
                        }
                    }
                }
                .navigationTitle("Search by Skills")
            }
        }
        // Sheet for editing a character - using item presentation for reliability
        .sheet(item: $selectedCharacter) { character in
            NavigationStack {
                AddCharacterView(character: character)
            }
        }
    }

    private func dropdownCount() -> Int {
        // Maximum number of skill dropdowns to show
        let maxDropdowns = min(5, allCharacters.flatMap { ($0.skills ?? []).map { $0.name } }.count)
        
        // Calculate how many dropdowns to show based on current selections and available skills
        var count = min(selectedSkills.count + 1, maxDropdowns)
        var remainingCharacters = filteredCharacters // Use filtered characters based on all current selections
        
        // If we're down to 1 character and have at least one selection, don't show more dropdowns
        if remainingCharacters.count <= 1 && !selectedSkills.isEmpty {
            return selectedSkills.count
        }
        
        // Check if there are any remaining skills for an additional dropdown
        if !selectedSkills.isEmpty {
            let usedSet = Set(selectedSkills)
            let available = availableSkills(for: selectedSkills.count)
            
            if available.isEmpty {
                return selectedSkills.count
            }
        }
        
        return count
    }
    
    private func performSearch() {
        // Sort the filtered characters by name, then by set
        searchResults = filteredCharacters.sorted { char1, char2 in
            if char1.name != char2.name {
                return char1.name < char2.name // Primary sort by name
            } else {
                // Secondary sort by set if names are identical
                let set1 = char1.set ?? ""
                let set2 = char2.set ?? ""
                return set1 < set2
            }
        }
        hasSearched = true
    }
}

// Component to display skills with highlighting for matches
struct SkillsView: View {
    let allSkills: [String]
    let highlightSkills: [String]
    
    var body: some View {
        Text(attributedSkillsString)
            .font(.caption)
    }
    
    private var attributedSkillsString: AttributedString {
        var result = AttributedString("")
        
        // Get the skills sorted by position if they're from a character
        for (index, skill) in allSkills.enumerated() {
            var skillText = AttributedString(skill)
            
            // Determine if this skill should be highlighted
            let shouldHighlight = isSkillHighlighted(skill)
            
            // Apply highlighting
            if shouldHighlight {
                skillText.foregroundColor = .blue
                skillText.font = .caption.bold()
            } else {
                skillText.foregroundColor = .secondary
            }
            
            result.append(skillText)
            
            // Add separators between skills
            if index < allSkills.count - 1 {
                var separator = AttributedString(", ")
                separator.foregroundColor = .secondary
                result.append(separator)
            }
        }
        
        return result
    }
    
    // Determine if a skill should be highlighted based on direct matches or group matches
    private func isSkillHighlighted(_ skill: String) -> Bool {
        // Direct match
        if highlightSkills.contains(skill) {
            return true
        }
        
        // Check if this skill matches any group
        if let colonIndex = skill.firstIndex(of: ":") {
            let prefix = String(skill[..<colonIndex]).trimmingCharacters(in: .whitespaces)
            if highlightSkills.contains(prefix) {
                return true
            }
        }
        
        return false
    }
}


----- FILE: /Users/steve/Library/Mobile Documents/com~apple~CloudDocs/AppProjects/ActionTracker/ActionTracker/Data/Data.swift -----
//
//  Data.swift
//  ActionTracker
//
//  Created by Stephen Parker on 4/2/25.
//

import SwiftUI

struct ActionItem: Identifiable, Codable, Equatable {
    var id: UUID
    var label: String
    var isUsed: Bool

    // Returns the default three actions
    static func defaultActions() -> [ActionItem] {
        return [
            ActionItem(id: UUID(), label: "Action 1", isUsed: false),
            ActionItem(id: UUID(), label: "Action 2", isUsed: false),
            ActionItem(id: UUID(), label: "Action 3", isUsed: false)
        ]
    }
    
    // Codable conformance is auto-synthesized since all properties are Codable
    
    // Equatable to detect changes for persistence
    static func == (lhs: ActionItem, rhs: ActionItem) -> Bool {
        return lhs.id == rhs.id && lhs.label == rhs.label && lhs.isUsed == rhs.isUsed
    }
}

struct Action: Identifiable, Hashable {
    var id: String = UUID().uuidString
    var image: String
    var title: String
}

let actions: [Action] = [
    .init(image: "star.circle.fill", title: "Action"),
    .init(image: "figure.socialdance.circle.fill", title: "Combat"),
    .init(image: "figure.fencing.circle.fill", title: "Melee"),
    .init(image: "figure.archery.circle.fill", title: "Ranged"),
    .init(image: "figure.run.circle.fill", title: "Move"),
    .init(image: "flashlight.on.circle.fill", title: "Search"),
]

/// For custom keypad entry
struct KeyPad: Identifiable {
    var id: String = UUID().uuidString
    var title: String
    var value: Int
    var isBack: Bool = false
}

let keypadValues: [KeyPad] = (1...9).compactMap({ .init(title: String("\($0)"), value: $0) }) + [
    .init(title: "0", value: 0),
    .init(title: "chevron.left", value: -1, isBack: true)
]


----- FILE: /Users/steve/Library/Mobile Documents/com~apple~CloudDocs/AppProjects/ActionTracker/ActionTracker/Data/Character.swift -----
//
//  Character.swift
//  ZombicideCharacters
//
//  Created by Stephen Parker on 4/11/25.
//

import Foundation
import SwiftData

@Model
class Character {
    // Remove unique constraint as it's not supported with CloudKit
    var name: String = ""
    var set: String?
    var notes: String?
    var isFavorite: Bool = false
    
    // Many-to-many relationship with skills - made optional for CloudKit compatibility
    var blueSkills: [String] = []
    var orangeSkills: [String] = []
    var redSkills: [String] = []
    
    // Active skills per power level 
    var activeBlueSkills: [String] = []
    var activeOrangeSkills: [String] = []
    var activeRedSkills: [String] = []
    
    // Optional relationship for CloudKit compatibility
    @Relationship(deleteRule: .cascade)
    var skills: [Skill]? = []
    
    init(name: String, set: String? = nil, notes: String? = nil, isFavorite: Bool = false, blueSkills: [String] = [], orangeSkills: [String] = [], redSkills: [String] = []) {
        self.name = name
        self.set = set
        self.notes = notes
        self.isFavorite = isFavorite
        
        print("CHARACTER INITIALIZATION")
        print("Creating new character: \(name) with blue: \(blueSkills.count), orange: \(orangeSkills.count), red: \(redSkills.count) skills")
        
        // Store skill lists exactly as provided - no modification
        self.blueSkills = blueSkills
        self.orangeSkills = orangeSkills
        self.redSkills = redSkills
        
        // Blue skills start active by default
        self.activeBlueSkills = self.blueSkills
        
        // Make sure skills array is empty to start with
        skills = []
        
        // Only create skill objects if we have actual skills
        if !blueSkills.isEmpty || !orangeSkills.isEmpty || !redSkills.isEmpty {
            // Create a brand new skills array for this character
            // with absolutely no existing entries
            skills = []
            
            // Convert string skills to Skill objects
            var skillPosition = 0
            
            // Create skills in color order - blue, orange, red
            // Use the exact lists provided with no deduplication
            for skillName in blueSkills {
                let skill = Skill(name: skillName, position: skillPosition, manual: true, color: .blue)
                skills?.append(skill)
                print("Created skill: \(skillName) (Color: blue, Position: \(skillPosition))")
                skillPosition += 1
            }
    
            for skillName in orangeSkills {
                let skill = Skill(name: skillName, position: skillPosition, manual: true, color: .orange)
                skills?.append(skill)
                print("Created skill: \(skillName) (Color: orange, Position: \(skillPosition))")
                skillPosition += 1
            }
    
            for skillName in redSkills {
                let skill = Skill(name: skillName, position: skillPosition, manual: true, color: .red)
                skills?.append(skill)
                print("Created skill: \(skillName) (Color: red, Position: \(skillPosition))")
                skillPosition += 1
            }
            
            print("Created \(skills?.count ?? 0) skills for character \(name)")
        }
        
        // Verify skills
        if let skillList = skills {
            print("Found \(skillList.count) skills for character \(name)")
            for skill in skillList {
                print("Loaded skill: \(skill.name) (Color: \(String(describing: skill.color)), Position: \(skill.position))")
            }
        }
    }
    
    // Returns all active skills in proper order (blue, orange, red) - optimized version
    func allActiveSkills() -> [String] {
        // Pre-allocate capacity to avoid multiple array resizing operations
        var result = [String]()
        result.reserveCapacity(activeBlueSkills.count + activeOrangeSkills.count + activeRedSkills.count)
        
        // Append using a single operation for each color
        result.append(contentsOf: activeBlueSkills)
        result.append(contentsOf: activeOrangeSkills)
        result.append(contentsOf: activeRedSkills)
        
        return result
    }
    
    // Activates a skill based on experience level
    func activateSkill(name: String, color: SkillColor) -> Bool {
        switch color {
        case .blue:
            // Blue skills are always active by default
            if !activeBlueSkills.contains(name) && blueSkills.contains(name) {
                activeBlueSkills.append(name)
                return true
            }
        case .orange:
            if !activeOrangeSkills.contains(name) && orangeSkills.contains(name) {
                activeOrangeSkills.append(name)
                return true
            }
        case .red:
            if !activeRedSkills.contains(name) && redSkills.contains(name) {
                activeRedSkills.append(name)
                return true
            }
        }
        return false
    }
    
    // Deactivates a skill
    func deactivateSkill(name: String, color: SkillColor) -> Bool {
        switch color {
        case .blue:
            if let index = activeBlueSkills.firstIndex(of: name) {
                activeBlueSkills.remove(at: index)
                return true
            }
        case .orange:
            if let index = activeOrangeSkills.firstIndex(of: name) {
                activeOrangeSkills.remove(at: index)
                return true
            }
        case .red:
            if let index = activeRedSkills.firstIndex(of: name) {
                activeRedSkills.remove(at: index)
                return true
            }
        }
        return false
    }
    
    // Returns skills that can be activated based on experience level
    func availableSkillsForExperience(_ experience: Int) -> (blue: [String], orange: [String], red: [String]) {
        // Blue skills are always available
        let availableBlueSkills = blueSkills.filter { !activeBlueSkills.contains($0) }
        
        // Orange skills become available at XP 19
        var availableOrangeSkills: [String] = []
        
        // Calculate how many orange skills can be activated based on XP
        if experience >= 19 {
            let cyclesPast19 = (experience - 19) / 43
            let maxActiveOrange = 1 + cyclesPast19
            if activeOrangeSkills.count < maxActiveOrange {
                availableOrangeSkills = orangeSkills.filter { !activeOrangeSkills.contains($0) }
            }
        }
        
        // Red skills become available at XP 43
        var availableRedSkills: [String] = []
        
        // Calculate how many red skills can be activated based on XP
        if experience >= 43 {
            let cyclesPast43 = (experience - 43) / 43 + 1
            let maxActiveRed = cyclesPast43
            if activeRedSkills.count < maxActiveRed {
                availableRedSkills = redSkills.filter { !activeRedSkills.contains($0) }
            }
        }
        
        return (availableBlueSkills, availableOrangeSkills, availableRedSkills)
    }
}


----- FILE: /Users/steve/Library/Mobile Documents/com~apple~CloudDocs/AppProjects/ActionTracker/ActionTracker/Data/Campaign.swift -----
//
//  Campaign.swift
//  ActionTracker
//
//  Created by Stephen Parker on 4/22/25.
//

import Foundation
import SwiftData

@Model
public final class Campaign {
    public var id: UUID = UUID()
    
    // Campaign Information
    public var campaignName: String = ""
    public var campaignDescription: String?
    public var startDate: Date = Date()
    public var endDate: Date?

    // Survivor Information
    public var survivorName: String = ""
    public var totalCXP: Int = 0

    // Progress Tracking
    public var campaignSkills: [String] = []
    public var bonusActions: Int = 0
    public var bonusActionsEarned: Int = 0
    public var campaignAchievements: [String] = []
    public var equipmentKept: [String] = []

    // Missions Relationship
    @Relationship(deleteRule: .cascade, inverse: \Mission.campaign)
    public var missions: [Mission]? = []
    
    public init(
        campaignName: String,
        survivorName: String,
        campaignDescription: String? = nil,
        startDate: Date = Date()
    ) {
        self.campaignName = campaignName
        self.survivorName = survivorName
        self.campaignDescription = campaignDescription
        self.startDate = startDate
        self.missions = []
    }
}

@Model
public final class Mission {
    public var id: UUID = UUID()
    
    public var missionName: String = ""
    public var datePlayed: Date = Date()
    public var cxpEarned: Int = 0
    public var objectivesCompleted: [String] = []
    public var bonusActionsUsed: Int = 0 // This is now "Bonus Actions Earned"
    public var notes: String?
    public var equipmentGained: [String] = []

    public var campaign: Campaign?
    
    public init(
        missionName: String,
        cxpEarned: Int,
        objectivesCompleted: [String] = [],
        bonusActionsUsed: Int = 0, // Renamed semantically to "Bonus Actions Earned"
        equipmentGained: [String] = [],
        notes: String? = nil
    ) {
        self.missionName = missionName
        self.cxpEarned = cxpEarned
        self.objectivesCompleted = objectivesCompleted
        self.bonusActionsUsed = bonusActionsUsed
        self.equipmentGained = equipmentGained
        self.notes = notes
    }
}


----- FILE: /Users/steve/Library/Mobile Documents/com~apple~CloudDocs/AppProjects/ActionTracker/ActionTracker/Data/AppViewModel.swift -----
//
//  AppViewModel.swift
//  ActionTracker
//
//  Created by Stephen Parker on 4/27/25.
//

import SwiftUI
import SwiftData
import Combine
import OSLog

/// Central application state manager to optimize data flow and avoid redundant operations
class AppViewModel: ObservableObject {
    // MARK: - Properties
    
    // Logger
    private let logger = Logger(subsystem: "com.parker1978.ActionTracker", category: "AppViewModel")
    
    // Character state
    @Published private(set) var characters: [Character] = []
    @Published private(set) var selectedCharacter: Character?
    @Published private(set) var filteredCharacters: [Character] = []
    @Published var searchText: String = "" {
        didSet { filterCharacters() }
    }
    
    // Experience tracking
    @AppStorage("playerExperience") var experience: Int = 0 {
        willSet { objectWillChange.send() }
    }
    @AppStorage("ultraRedCount") var ultraRedCount: Int = 0 {
        willSet { objectWillChange.send() }
    }
    @AppStorage("totalExperienceGained") var totalExperienceGained: Int = 0 {
        willSet { objectWillChange.send() }
    }
    
    // Selected character persistence
    @AppStorage("selectedCharacterName") var selectedCharacterName: String = "" {
        willSet { objectWillChange.send() }
    }
    @AppStorage("selectedCharacterSet") var selectedCharacterSet: String = "" {
        willSet { objectWillChange.send() }
    }
    
    // Mission tracking
    @AppStorage("currentMissionID") var currentMissionID: String = "" {
        willSet { objectWillChange.send() }
    }
    @AppStorage("missionStartXP") var missionStartXP: Int = 0 {
        willSet { objectWillChange.send() }
    }
    
    // UI state
    @Published var showCharacterPicker = false
    @Published var showSkillManager = false
    
    // Data context
    private var modelContext: ModelContext?
    
    // MARK: - Initialization
    
    init() {
        // Initialize with empty state
        logger.debug("AppViewModel initialized")
    }
    
    // MARK: - Data Management
    
    /// Configure with SwiftData context
    func configure(with context: ModelContext) {
        self.modelContext = context
        logger.debug("ModelContext configured")
        
        // Initial fetch
        fetchCharacters()
        
        // Try to restore previously selected character
        restoreSelectedCharacter()
    }
    
    /// Fetch all characters with optimized sorting
    func fetchCharacters() {
        guard let context = modelContext else {
            logger.error("ModelContext not available for fetchCharacters")
            return
        }
        
        do {
            var descriptor = FetchDescriptor<Character>()
            descriptor.sortBy = [SortDescriptor(\Character.name)]
            
            // Fetch within try block since it can throw
            var fetchedCharacters = try context.fetch(descriptor)
            
            // Sort favorites to the top manually - only once
            fetchedCharacters.sort { (char1, char2) -> Bool in
                if char1.isFavorite && !char2.isFavorite {
                    return true
                } else if !char1.isFavorite && char2.isFavorite {
                    return false
                } else {
                    return char1.name.localizedCaseInsensitiveCompare(char2.name) == .orderedAscending
                }
            }
            
            // Update state all at once
            self.characters = fetchedCharacters
            filterCharacters()
            
            logger.debug("Fetched \(fetchedCharacters.count) characters")
        } catch {
            logger.error("Error fetching characters: \(error.localizedDescription)")
            self.characters = []
            filterCharacters()
        }
    }
    
    /// Filter characters based on search text - computed once
    private func filterCharacters() {
        if searchText.isEmpty {
            filteredCharacters = characters
        } else {
            filteredCharacters = characters.filter {
                $0.name.localizedCaseInsensitiveContains(searchText) ||
                ($0.set ?? "").localizedCaseInsensitiveContains(searchText)
            }
        }
    }
    
    /// Attempt to restore previously selected character
    private func restoreSelectedCharacter() {
        if !selectedCharacterName.isEmpty {
            selectedCharacter = characters.first { character in
                character.name == selectedCharacterName && 
                (character.set ?? "") == selectedCharacterSet
            }
            
            if selectedCharacter != nil {
                logger.debug("Restored selected character: \(self.selectedCharacterName)")
            }
        }
    }
    
    /// Select a character and save selection
    func selectCharacter(_ character: Character) {
        selectedCharacter = character
        selectedCharacterName = character.name
        selectedCharacterSet = character.set ?? ""
        
        // Reset character skills when selected - only blue skills should be active
        resetCharacterSkills(character)
        
        logger.debug("Selected character: \(character.name)")
    }
    
    /// Clear selected character
    func clearSelectedCharacter() {
        selectedCharacter = nil
        selectedCharacterName = ""
        selectedCharacterSet = ""
        
        logger.debug("Cleared selected character")
    }
    
    // MARK: - Experience Management
    
    /// Get color based on experience level - cached
    func getExperienceColor() -> Color {
        // For starting level
        if experience == 0 {
            return .gray
        }
        
        // Determine cycle (1-based) and base level
        let cycle = ((experience - 1) / 43) + 1
        let baseLevel = ((experience - 1) % 43) + 1
        
        // Base colors
        let blueColor = Color(red: 0.0, green: 0.5, blue: 1.0)
        let yellowColor = Color(red: 1.0, green: 0.84, blue: 0.0)
        let orangeColor = Color(red: 1.0, green: 0.6, blue: 0.0)
        let redColor = Color(red: 1.0, green: 0.2, blue: 0.2)
        
        // In Ultra-Red mode (cycle > 1), use more intense colors
        if cycle > 1 {
            // For Ultra-Red cycles, use more vibrant colors with subtle glow effect
            switch baseLevel {
            case 1...6:
                // Ultra-Blue: more vibrant blue
                return Color(red: 0.1, green: 0.4, blue: 1.0)
            case 7...18:
                // Ultra-Yellow: more vibrant yellow/gold
                return Color(red: 1.0, green: 0.85, blue: 0.2)
            case 19...42:
                // Ultra-Orange: more vibrant orange
                return Color(red: 1.0, green: 0.5, blue: 0.0)
            case 43:
                // Ultra-Red: bright crimson red
                return Color(red: 0.85, green: 0.0, blue: 0.0)
            default:
                return .gray
            }
        } else {
            // Standard colors for first cycle
            switch baseLevel {
            case 1...6:
                return blueColor
            case 7...18:
                return yellowColor
            case 19...42:
                return orangeColor
            case 43:
                return redColor
            default:
                return .gray
            }
        }
    }
    
    /// Get level label based on experience - cached
    func getLevelLabel() -> String {
        if experience == 0 {
            return "Novice"
        }
        
        // Calculate which cycle we're in (0-based)
        let baseLevel = experience == 0 ? 0 : ((experience - 1) % 43) + 1
        
        // Determine level name based only on the base level
        switch baseLevel {
        case 1...6:
            return "Blue"
        case 7...18:
            return "Yellow"
        case 19...42:
            return "Orange"
        case 43:
            return "Red"
        default:
            return "Novice"
        }
    }
    
    /// Get the current base level (1-43)
    func getCurrentBaseLevel() -> Int {
        if experience == 0 {
            return 0
        }
        return ((experience - 1) % 43) + 1
    }
    
    /// Check if in ultra-red mode (beyond first level 43)
    func isUltraMode() -> Bool {
        return experience > 43
    }
    
    /// Calculate max orange skills based on experience (including ultra cycles)
    func getMaxOrangeSkills() -> Int {
        if experience < 19 {
            return 0
        }
        
        // Calculate ultra cycles (0-based)
        let orangeUltraCycles = ((experience - 19) / 43)
        return 1 + orangeUltraCycles // 1 is base orange skill count
    }
    
    /// Calculate max red skills based on experience (including ultra cycles)
    func getMaxRedSkills() -> Int {
        if experience < 43 {
            return 0
        }
        
        // Calculate ultra cycles (0-based)
        let redUltraCycles = ((experience - 43) / 43)
        return 1 + redUltraCycles // 1 is base red skill count
    }
    
    /// Update experience with side effects
    func updateExperience(_ newValue: Int) {
        let oldValue = experience
        experience = newValue
        
        // Track total experience gained
        if newValue > oldValue {
            totalExperienceGained += (newValue - oldValue)
        }
        
        // Handle level transitions - base level calculation is crucial
        let oldBaseLevel = oldValue == 0 ? 0 : ((oldValue - 1) % 43) + 1
        let newBaseLevel = newValue == 0 ? 0 : ((newValue - 1) % 43) + 1
        
        // When base level goes from 43 to something higher (which would wrap to 1+)
        if oldBaseLevel == 43 && newBaseLevel < oldBaseLevel && newValue > oldValue {
            // We've gone past level 43 - increment ultra count
            ultraRedCount += 1
        }
        
        logger.debug("Updated experience: \(oldValue) -> \(newValue)")
    }
    
    // MARK: - Character Skill Management
    
    /// Reset a character's skills to default state (only blue skills active)
    func resetCharacterSkills(_ character: Character) {
        guard let context = modelContext else {
            logger.error("ModelContext not available for resetCharacterSkills")
            return
        }
        
        // Keep all blue skills active
        character.activeBlueSkills = character.blueSkills
        
        // Reset orange and red skills (none active)
        character.activeOrangeSkills = []
        character.activeRedSkills = []
        
        // Save changes to the database
        do {
            try context.save()
            logger.debug("Reset skills for character: \(character.name)")
        } catch {
            logger.error("Error saving character skill reset: \(error.localizedDescription)")
        }
    }
    
    /// Reset all experience tracking
    func resetExperience() {
        experience = 0
        ultraRedCount = 0
        totalExperienceGained = 0
        
        logger.debug("Reset all experience values")
    }
    
    // MARK: - Mission Tracking
    
    /// Start tracking a new mission
    func startTrackingMission(missionID: String) {
        self.currentMissionID = missionID
        self.missionStartXP = experience
        logger.debug("Started tracking mission: \(missionID), starting XP: \(self.missionStartXP)")
    }
    
    /// Update mission notes with the gameplay information
    func updateMissionNotes(elapsedTime: TimeInterval) -> Bool {
        print("DEBUG: Updating mission notes, elapsed time: \(elapsedTime)")
        print("DEBUG: Current mission ID: \(self.currentMissionID), has context: \(modelContext != nil)")
        
        guard !self.currentMissionID.isEmpty, let context = modelContext else {
            logger.error("Cannot update mission notes: no current mission or context")
            print("DEBUG: Failed to update mission notes - missing mission ID or context")
            return false
        }
        
        // Find the mission using the UUID string
        guard let missionUUID = UUID(uuidString: self.currentMissionID) else {
            logger.error("Invalid mission UUID: \(self.currentMissionID)")
            print("DEBUG: Failed to parse UUID from: \(self.currentMissionID)")
            return false
        }
        
        print("DEBUG: Looking for mission with UUID: \(missionUUID)")
        
        do {
            // Create a predicate to find the mission
            let missionDescriptor = FetchDescriptor<Mission>(predicate: #Predicate<Mission> { mission in
                mission.id == missionUUID
            })
            
            let missions = try context.fetch(missionDescriptor)
            print("DEBUG: Found \(missions.count) missions matching UUID")
            
            guard let mission = missions.first else {
                logger.error("Mission not found: \(self.currentMissionID)")
                print("DEBUG: No mission found with UUID: \(missionUUID)")
                return false
            }
            
            print("DEBUG: Found mission: \(mission.missionName)")
            
            // Calculate time played
            let hours = Int(elapsedTime) / 3600
            let minutes = (Int(elapsedTime) % 3600) / 60
            let timeString = "\(hours) hour\(hours == 1 ? "" : "s") \(minutes) minute\(minutes == 1 ? "" : "s") played"
            print("DEBUG: Time string: \(timeString)")
            
            // Calculate XP gained during mission
            let xpGained = self.experience - self.missionStartXP
            print("DEBUG: XP gained during mission: \(xpGained) (start: \(self.missionStartXP), current: \(self.experience))")
            
            // Format the current level with Ultra information if applicable
            let baseLevel = getCurrentBaseLevel()
            let totalAP = experience // Use total AP (experience) rather than base level
            let levelName = getLevelLabel()
            
            // For display in notes, we want to add ULTRA information for levels > 43
            let displayLevelName: String
            if isUltraMode() {
                // Calculate which Ultra cycle we're in (1-based)
                let cycle = ((experience - 1) / 43) + 1
                // First Ultra cycle (cycle = 2) shows just "ULTRA"
                // Second Ultra cycle (cycle = 3) shows "ULTRA X"
                // Third Ultra cycle (cycle = 4) shows "ULTRA XX" etc.
                let xCount = max(0, cycle - 2)  // No X's for first Ultra
                let ultraSuffix = xCount > 0 ? " ULTRA " + String(repeating: "X", count: xCount) : " ULTRA"
                displayLevelName = "\(levelName)\(ultraSuffix)"
            } else {
                displayLevelName = levelName
            }
            
            print("DEBUG: Current level: \(displayLevelName) (\(totalAP) AP)")
            
            // Create or update notes - use total AP (experience) not base level
            let missionInfo = "\n\(timeString)\nLevel: \(displayLevelName) (\(totalAP) AP)"
            print("DEBUG: Mission info to add: \(missionInfo)")
            
            // Check existing notes
            if let existingNotes = mission.notes, !existingNotes.isEmpty {
                print("DEBUG: Existing notes: \(existingNotes)")
                
                // Check if the mission note already has timing information (to avoid duplications)
                if existingNotes.contains(" played\n") {
                    print("DEBUG: Notes already contain play time, updating...")
                    // Note already has timing info, likely going to update it
                    // Find the position to update
                    if let playedRange = existingNotes.range(of: " played\n") {
                        // Find the starting position of the play time info
                        // We search backwards for a newline before the "played" string
                        let searchStart = existingNotes.startIndex
                        let searchEnd = playedRange.lowerBound
                        let searchRange = searchStart..<searchEnd
                        
                        if let lastNewline = existingNotes[searchRange].lastIndex(of: "\n") {
                            // Extract the part before the timing info
                            let notesWithoutTiming = existingNotes[..<lastNewline]
                            mission.notes = String(notesWithoutTiming) + missionInfo
                            print("DEBUG: Updated existing play time info")
                        } else {
                            // Can't find where to update, append
                            mission.notes = existingNotes + missionInfo
                            print("DEBUG: Couldn't find exact play time section start, appending")
                        }
                    } else {
                        // Can't find where to update, append
                        mission.notes = existingNotes + missionInfo
                        print("DEBUG: Couldn't find play time section to update, appending")
                    }
                } else {
                    // Append to existing notes
                    mission.notes = existingNotes + missionInfo
                    print("DEBUG: Appending play time to existing notes")
                }
            } else {
                // Create new notes with just the session info - remove leading newline for new notes
                mission.notes = timeString + "\nLevel: \(displayLevelName) (\(totalAP) AP)"
                print("DEBUG: Creating new notes with play time")
            }
            
            print("DEBUG: Final notes: \(mission.notes ?? "nil")")
            
            try context.save()
            print("DEBUG: Successfully saved mission notes")
            
            // Reset mission tracking
            currentMissionID = ""
            missionStartXP = 0
            print("DEBUG: Reset mission tracking variables")
            
            logger.debug("Updated mission notes for \(missionUUID) with play time and level info")
            return true
        } catch {
            logger.error("Failed to update mission notes: \(error.localizedDescription)")
            print("DEBUG ERROR: Failed to update mission notes: \(error)")
            return false
        }
    }
}


----- FILE: /Users/steve/Library/Mobile Documents/com~apple~CloudDocs/AppProjects/ActionTracker/ActionTracker/Data/Skill.swift -----
//
//  Skill.swift
//  ActionTracker
//
//  Created by Stephen Parker on 4/19/25.
//

import Foundation
import SwiftData

enum SkillColor: String, Codable {
    case blue
    case orange
    case red
}

@Model
class Skill {
    // Unique identifier for the skill - removed unique constraint for CloudKit compatibility
    var id: UUID = UUID()
    
    // The name of the skill - added default empty string for CloudKit compatibility
    var name: String = ""
    
    // Description of how the skill is used
    var skillDescription: String = ""
    
    // Position in the character's skill list (for maintaining order)
    var position: Int = 0
    
    // Flag to indicate if the skill was manually created
    var manual: Bool = false
    
    // Skill color level - optional for CloudKit compatibility
    var color: SkillColor? = SkillColor.blue
    
    // Flag to indicate if the skill was created during a CSV import
    var importedFlag: Bool = false
    
    // Relationship to characters - made optional for CloudKit compatibility
    var characters: [Character]? = []
    
    // Normalizes skill names to be consistent regardless of original case
    static func normalizeSkillName(_ name: String) -> String {
        // First trim leading/trailing spaces
        let trimmed = name.trimmingCharacters(in: .whitespacesAndNewlines)
        
        // Replace multiple spaces with single spaces
        let noDoubleSpaces = trimmed.replacingOccurrences(of: "\\s{2,}", with: " ", options: .regularExpression)
        
        // Then capitalize each word
        return noDoubleSpaces.capitalized
    }
    
    // Lowercase version of name for case-insensitive comparison
    @Transient
    var normalizedName: String {
        // Get lowercase version for comparison
        return name.lowercased()
    }
    
    init(name: String, skillDescription: String = "", position: Int = 0, manual: Bool = false, importedFlag: Bool = false, color: SkillColor) {
        // Store the name with consistent capitalization (each word capitalized)
        self.name = Skill.normalizeSkillName(name)
        self.skillDescription = skillDescription
        self.position = position
        self.manual = manual
        self.importedFlag = importedFlag
        self.color = color // This will work even though color is optional now
        self.characters = [] // Initialize as empty array for CloudKit compatibility
    }
    
    // Convenience initializer with default blue color
    convenience init(name: String, skillDescription: String = "", position: Int = 0, manual: Bool = false, importedFlag: Bool = false) {
        self.init(name: name, skillDescription: skillDescription, position: position, manual: manual, importedFlag: importedFlag, color: .blue)
    }
}


----- FILE: /Users/steve/Library/Mobile Documents/com~apple~CloudDocs/AppProjects/ActionTracker/ActionTracker/ContentView.swift -----
//
//  ContentView.swift
//  ActionTracker
//
//  Created by Stephen Parker on 4/1/25.
//

import SwiftUI
import SwiftData

struct ContentView: View {
    // Main app state via EnvironmentObject
    @EnvironmentObject private var appViewModel: AppViewModel
    
    // Required SwiftData model context to configure the view model
    @Environment(\.modelContext) private var modelContext
    
    // Persist state using AppStorage
    @AppStorage("keepAwakeEnabled") private var keepAwake: Bool = false
    @AppStorage("activeViewTab") private var activeViewString: String = "action"
    
    // Transform the string-based AppStorage to enum for the view
    @State private var currentView: ViewType = .action
    @State private var isShowingAddCharacter = false
    
    // Timer state
    @State private var timerIsRunning: Bool = false
    
    // Actions state with custom persistence via Codable
    @State private var actionItems: [ActionItem] = []
    
    var body: some View {
        VStack {
            HeaderView(keepAwake: $keepAwake, 
                       currentView: $currentView, 
                       actionItems: $actionItems, 
                       isShowingAddCharacter: $isShowingAddCharacter,
                       timerRunningBinding: $timerIsRunning)
            
            switch currentView {
            case .action:
                ActionView(actionItems: $actionItems, timerIsRunning: $timerIsRunning)
            case .character:
                CharacterListView(isShowingAddCharacter: $isShowingAddCharacter)
            case .campaign:
                CampaignView()
            }
        }
        .onChange(of: keepAwake) {
            UIApplication.shared.isIdleTimerDisabled = keepAwake
        }
        .onChange(of: currentView) { _, newValue in
            // Save the view type when it changes
            switch newValue {
            case .action:
                activeViewString = "action"
            case .character:
                activeViewString = "character"
            case .campaign:
                activeViewString = "campaign"
            }
        }
        .onChange(of: actionItems) { _, newItems in
            // Save actionItems when they change
            saveActionItems(newItems)
        }
        .onAppear {
            // Initialize the AppViewModel with the model context
            appViewModel.configure(with: modelContext)
            
            // Initialize the view state from AppStorage
            switch activeViewString {
            case "action":
                currentView = .action
            case "character":
                currentView = .character
            case "campaign":
                currentView = .campaign
            default:
                currentView = .action
            }
            
            // Load saved actions if available, otherwise use defaults
            if let savedItems = loadActionItems() {
                actionItems = savedItems
            } else {
                actionItems = ActionItem.defaultActions()
            }
            
            // Apply idle timer setting
            UIApplication.shared.isIdleTimerDisabled = keepAwake
        }
    }
    
    // Save action items to UserDefaults - now in a more efficient way
    private func saveActionItems(_ items: [ActionItem]) {
        Task {
            // Move encoding to background thread
            guard let encoded = try? JSONEncoder().encode(items) else {
                print("Failed to encode action items")
                return
            }
            
            // UI updates back on main thread
            await MainActor.run {
                UserDefaults.standard.set(encoded, forKey: "savedActionItems")
            }
        }
    }
    
    // Load action items from UserDefaults
    private func loadActionItems() -> [ActionItem]? {
        guard let data = UserDefaults.standard.data(forKey: "savedActionItems"),
              let decoded = try? JSONDecoder().decode([ActionItem].self, from: data) else {
            return nil
        }
        return decoded
    }
}

#Preview {
    ContentView()
        .environmentObject(AppViewModel())
}


----- FILE: /Users/steve/Library/Mobile Documents/com~apple~CloudDocs/AppProjects/ActionTracker/ActionTracker/Helpers/KeyboardToolbarHelper.swift -----
//
//  KeyboardToolbarHelper.swift
//  ActionTracker
//
//  Created by Stephen Parker on 4/27/25.
//

import SwiftUI

struct KeyboardToolbar: ViewModifier {
    var onInsertText: (String) -> Void
    var onDone: () -> Void
    
    func body(content: Content) -> some View {
        content
            .toolbar {
                // +1 button on the left
                ToolbarItem(placement: .keyboard) {
                    Button("+1") {
                        onInsertText("+1 ")
                    }
                }
                
                // Colon button on the left center
                ToolbarItem(placement: .keyboard) {
                    Button(":") {
                        onInsertText(": ")
                    }
                }
                
                // Timestamp button in the center
                ToolbarItem(placement: .keyboard) {
                    Button("") {
                        onInsertText(formattedDateTime() + " ")
                    }
                }
                
                // Spacer to push Done button to the right
                ToolbarItem(placement: .keyboard) {
                    Spacer()
                }
                
                // Done button on the right
                ToolbarItem(placement: .keyboard) {
                    Button("Done") {
                        onDone()
                    }
                }
            }
    }
    
    private func formattedDateTime() -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd HH:mm"
        return formatter.string(from: Date())
    }
}

extension View {
    func keyboardToolbar(onInsertText: @escaping (String) -> Void, onDone: @escaping () -> Void) -> some View {
        self.modifier(KeyboardToolbar(onInsertText: onInsertText, onDone: onDone))
    }
}

----- FILE: /Users/steve/Library/Mobile Documents/com~apple~CloudDocs/AppProjects/ActionTracker/ActionTracker/Helpers/TrayHelper.swift -----
//
//  TrayHelper.swift
//  SystemTray
//
//  Created by Balaji Venkatesh on 05/03/25.
//

import SwiftUI

struct TrayConfig {
    var maxDetent: PresentationDetent
    var cornerRadius: CGFloat = 30
    var isInteractiveDismissDisabled: Bool = false
    /// Add Other Properties as per your needs
    var horizontalPadding: CGFloat = 15
    var bottomPadding: CGFloat = 15
}

extension View {
    @ViewBuilder
    func systemTrayView<Content: View>(
        _ show: Binding<Bool>,
        config: TrayConfig = .init(maxDetent: .fraction(0.99)),
        @ViewBuilder content: @escaping () -> Content
    ) -> some View {
        self
            .sheet(isPresented: show) {
                content()
                    .background(.background)
                    .clipShape(.rect(cornerRadius: config.cornerRadius))
                    .padding(.horizontal, config.horizontalPadding)
                    .padding(.bottom, config.bottomPadding)
                    .frame(maxHeight: .infinity, alignment: .bottom)
                    /// Presentation Configurations
                    .presentationDetents([config.maxDetent])
                    .presentationCornerRadius(0)
                    .presentationBackground(.clear)
                    .presentationDragIndicator(.hidden)
                    .interactiveDismissDisabled(config.isInteractiveDismissDisabled)
                    .background(RemoveSheetShadow())
            }
    }
}

fileprivate struct RemoveSheetShadow: UIViewRepresentable {
    func makeUIView(context: Context) -> UIView {
        let view = UIView(frame: .zero)
        view.backgroundColor = .clear
        
        DispatchQueue.main.async {
            if let shadowView = view.dropShadowView {
                shadowView.layer.shadowColor = UIColor.clear.cgColor
            }
        }
        
        return view
    }
    
    func updateUIView(_ uiView: UIView, context: Context) {
        
    }
}

extension UIView {
    var dropShadowView: UIView? {
        if let superview, String(describing: type(of: superview)) == "UIDropShadowView" {
            return superview
        }
        
        return superview?.dropShadowView
    }
}


----- FILE: /Users/steve/Library/Mobile Documents/com~apple~CloudDocs/AppProjects/ActionTracker/ActionTracker/CharacterPickerView.swift -----
//
//  CharacterPickerView.swift
//  ActionTracker
//
//  Created by Stephen Parker on 4/27/25.
//

import SwiftUI
import SwiftData

struct CharacterPickerView: View {
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject private var appViewModel: AppViewModel
    
    var body: some View {
        NavigationStack {
            VStack {
                if appViewModel.characters.isEmpty {
                    ContentUnavailableView(
                        "No Characters Available",
                        systemImage: "person.fill.questionmark",
                        description: Text("Create some characters first by going to the Characters tab")
                    )
                } else {
                    List {
                        ForEach(appViewModel.filteredCharacters) { character in
                            Button {
                                appViewModel.selectCharacter(character)
                                dismiss()
                            } label: {
                                HStack {
                                    VStack(alignment: .leading) {
                                        HStack {
                                            if character.isFavorite {
                                                Image(systemName: "star.fill")
                                                    .foregroundColor(.yellow)
                                                    .font(.caption)
                                            }
                                            Text(character.name)
                                                .font(.headline)
                                        }
                                        
                                        if let set = character.set, !set.isEmpty {
                                            Text(set)
                                                .font(.caption)
                                                .foregroundColor(.secondary)
                                        }
                                    }
                                    
                                    Spacer()
                                    
                                    if appViewModel.selectedCharacter?.id == character.id {
                                        Image(systemName: "checkmark")
                                            .foregroundColor(.blue)
                                    }
                                }
                                .contentShape(Rectangle())
                            }
                            .buttonStyle(.plain)
                        }
                    }
                    .searchable(text: $appViewModel.searchText, prompt: "Search characters")
                }
            }
            .navigationTitle("Select Character")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
            }
            .onAppear {
                // Refresh character list
                appViewModel.fetchCharacters()
            }
        }
    }
}

#Preview {
    struct PreviewWrapper: View {
        @StateObject var viewModel = AppViewModel()
        
        var body: some View {
            CharacterPickerView()
                .environmentObject(viewModel)
        }
    }
    
    return PreviewWrapper()
}

